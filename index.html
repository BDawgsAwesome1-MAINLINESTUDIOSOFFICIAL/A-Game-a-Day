<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>A Game a Day ‚Äî Ultra AI Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<style>
:root{
  --accent1:#0b74d1;
  --accent2:#a11ad8;
  --accent3:#ff5a7a;
  --bg-dark:#0a0e27;
  --bg-card:rgba(255,255,255,0.08);
  --text-primary:#ffffff;
  --text-secondary:rgba(255,255,255,0.85);
  --shadow-sm:0 2px 8px rgba(0,0,0,0.1);
  --shadow-md:0 4px 16px rgba(0,0,0,0.2);
  --shadow-lg:0 8px 32px rgba(0,0,0,0.3);
  --shadow-xl:0 16px 48px rgba(0,0,0,0.4);
}
body{
  margin:0;
  font-family:"SF Pro Display","Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  background:linear-gradient(135deg,#0b74d1,#a11ad8,#ff5a7a);
  background-size:300% 300%;
  animation:bgShift 12s linear infinite;
  color:var(--text-primary);
  overflow-x:hidden;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}
@keyframes bgShift{
  0%{background-position:0% 50%;}
  50%{background-position:100% 50%;}
  100%{background-position:0% 50%;}
}
#appContainer{opacity:0;transition:opacity 0.6s;}
header{
  display:flex;align-items:center;justify-content:center;gap:16px;
  padding:24px 20px;
  backdrop-filter:blur(20px) saturate(180%);
  background:rgba(10,14,39,0.75);
  border-bottom:1px solid rgba(255,255,255,0.1);
  position:sticky;top:0;z-index:10;
  box-shadow:var(--shadow-md);
}
.logo{
  width:56px;height:56px;border-radius:14px;
  background:linear-gradient(135deg,#0b74d1,#a11ad8);
  color:#fff;
  display:flex;align-items:center;justify-content:center;
  font-weight:800;font-size:20px;
  cursor:pointer;
  box-shadow:var(--shadow-md);
  transition:all 0.3s ease;
}
.logo:hover{transform:scale(1.05) rotate(5deg);box-shadow:var(--shadow-lg);}
header h1{margin:0;font-size:22px;font-weight:700;color:var(--text-primary);letter-spacing:-0.5px;}
.tabs{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;padding:20px;backdrop-filter:blur(20px) saturate(180%);background:rgba(10,14,39,0.6);border-bottom:1px solid rgba(255,255,255,0.08);position:sticky;top:104px;z-index:9;box-shadow:var(--shadow-sm);}
.tab{background:rgba(255,255,255,0.08);color:var(--text-secondary);border:none;padding:12px 20px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s cubic-bezier(0.4,0,0.2,1);font-size:14px;position:relative;border:1px solid rgba(255,255,255,0.1);backdrop-filter:blur(10px);}
.tab:hover{background:rgba(255,255,255,0.15);transform:translateY(-2px);box-shadow:var(--shadow-md);color:var(--text-primary);}
.tab.active{background:linear-gradient(135deg,rgba(11,116,209,0.3),rgba(161,26,216,0.3));color:var(--text-primary);box-shadow:var(--shadow-md);border-color:rgba(255,255,255,0.2);}
.tab-badge{position:absolute;top:-6px;right:-6px;background:var(--accent3);color:#fff;border-radius:50%;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;}
.tab-content{display:none;animation:fadeIn 0.3s ease;}
.tab-content.active{display:block;}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
.container{max-width:1200px;margin:26px auto;padding:0 20px 80px;}
.controls{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-bottom:14px;}
input[type=text],input[type=number],select{min-width:220px;max-width:420px;padding:14px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.08);color:var(--text-primary);outline:none;font-size:14px;transition:all 0.3s;backdrop-filter:blur(10px);}
input[type=text]:focus,input[type=number]:focus,select:focus{border-color:rgba(11,116,209,0.5);background:rgba(255,255,255,0.12);box-shadow:0 0 0 3px rgba(11,116,209,0.1);}
input::placeholder{color:rgba(255,255,255,0.5);}
select{color:var(--text-primary);cursor:pointer;}
select option{background:#1a1a2e;color:#fff;}
.btn{background:linear-gradient(135deg,rgba(11,116,209,0.8),rgba(161,26,216,0.8));color:#fff;border:none;padding:14px 24px;border-radius:12px;font-weight:700;font-size:14px;cursor:pointer;transition:all 0.3s cubic-bezier(0.4,0,0.2,1);box-shadow:var(--shadow-md);letter-spacing:0.3px;}
.btn:hover{transform:translateY(-3px);box-shadow:var(--shadow-lg);background:linear-gradient(135deg,rgba(11,116,209,1),rgba(161,26,216,1));}
.btn:active{transform:translateY(-1px);}
.btn-small{padding:6px 10px;font-size:12px;}
.btn-fav{position:absolute;right:10px;top:10px;background:rgba(255,255,255,0.2);border:none;color:#fff;width:28px;height:28px;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:16px;transition:all .2s;}
.btn-fav:hover{background:rgba(255,255,255,0.3);transform:scale(1.1);}
.btn-fav.favorited{background:var(--accent3);color:#fff;}
.calendar{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:14px;}
.card{border-radius:16px;padding:18px;min-height:140px;position:relative;color:var(--text-primary);box-shadow:var(--shadow-lg);transition:all 0.3s cubic-bezier(0.4,0,0.2,1);overflow:hidden;border:1px solid rgba(255,255,255,0.1);backdrop-filter:blur(20px);background:linear-gradient(135deg,rgba(11,116,209,0.15),rgba(161,26,216,0.15));}
.card:hover{transform:translateY(-8px) scale(1.02);box-shadow:var(--shadow-xl);border-color:rgba(255,255,255,0.2);}
.card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:linear-gradient(90deg,#0b74d1,#a11ad8,#ff5a7a);opacity:0;transition:opacity 0.3s;}
.card:hover::before{opacity:1;}
.num{font-weight:800;margin-bottom:8px;}
.short{font-size:14px;line-height:1.4;color:rgba(255,255,255,0.95);}
.tooltip{position:absolute;left:12px;top:10px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .18s;}
.card:hover .tooltip{opacity:1;}
.search-box{width:100%;max-width:600px;margin:0 auto 20px;position:relative;}
.search-box input{width:100%;padding-right:40px;}
.search-icon{position:absolute;right:12px;top:50%;transform:translateY(-50%);opacity:0.6;}
.stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin:20px 0;}
.stat-card{background:rgba(255,255,255,0.1);border-radius:12px;padding:20px;text-align:center;backdrop-filter:blur(10px);}
.stat-value{font-size:32px;font-weight:800;margin:8px 0;background:linear-gradient(90deg,#0b74d1,#a11ad8,#ff5a7a);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;}
.stat-label{font-size:14px;opacity:0.9;}
.settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin:20px 0;}
.setting-item{background:rgba(255,255,255,0.08);border-radius:10px;padding:16px;}
.setting-item label{display:block;margin-bottom:8px;font-weight:600;font-size:14px;}
.quick-idea-box{background:rgba(255,255,255,0.1);border-radius:14px;padding:24px;margin:20px auto;max-width:700px;text-align:center;backdrop-filter:blur(10px);}
.quick-idea-box h3{margin:0 0 16px;font-size:20px;}
.idea-display{background:rgba(0,0,0,0.2);border-radius:10px;padding:20px;margin:16px 0;text-align:left;}
.idea-display .idea-title{font-size:18px;font-weight:700;margin-bottom:12px;color:#fff;}
.idea-display .idea-desc{font-size:14px;line-height:1.6;opacity:0.95;}
.empty-state{text-align:center;padding:60px 20px;opacity:0.7;}
.empty-state-icon{font-size:48px;margin-bottom:16px;}
.modal{display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;z-index:1000;opacity:0;transition:opacity 0.5s ease;}
.modal.visible{display:flex;opacity:1;}
.panel{background:#fff;border-radius:12px;max-width:820px;width:92%;max-height:86%;overflow:auto;padding:22px;position:relative;color:#071226;transform:translateY(20px);transition:transform 0.4s ease;}
.modal.visible .panel{transform:translateY(0);}
.panel h2{margin:0 0 8px;font-size:18px;}
.panel p{margin:8px 0 0;color:#24303b;line-height:1.6;}
.close{position:absolute;right:12px;top:12px;border:none;background:transparent;font-size:20px;cursor:pointer;font-weight:700;}
.copy-btn{position:absolute;right:12px;bottom:12px;border:none;background:linear-gradient(90deg,#0b74d1,#a11ad8,#ff5a7a);color:#fff;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer;}
.share-btn{position:absolute;right:80px;bottom:12px;border:none;background:rgba(11,116,209,0.8);color:#fff;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer;}
.loadingOverlay{display:none;position:fixed;left:0;top:0;width:100%;height:100%;z-index:2000;align-items:center;justify-content:center;flex-direction:column;background:radial-gradient(circle at center,#001830,#000);transition:transform 0.5s ease,opacity 0.5s ease;}
.loadingOverlay.hidden{transform:translateY(-100%);opacity:0;}
.loadingCard{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));border-radius:14px;padding:18px;width:420px;max-width:92%;text-align:center;box-shadow:0 20px 70px rgba(2,8,23,0.5);}
.loadingCard h3{margin:0 0 8px;font-size:18px;color:#fff;}
.loadingInfo{font-size:13px;color:rgba(255,255,255,0.9);margin-bottom:12px;}
.progress{height:10px;background:rgba(255,255,255,0.08);border-radius:999px;overflow:hidden;}
.progress>i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#0b74d1,#a11ad8,#ff5a7a);transition:width .9s linear;}
</style>
</head>
<body>
<div id="appContainer">
<header>
  <div class="logo" id="logoBtn">AGD</div>
  <h1>A Game a Day ‚Äî Ultra AI Edition</h1>
</header>

<div class="tabs">
  <button class="tab active" data-tab="generator">üéÆ Generator</button>
  <button class="tab" data-tab="quick">‚ö° Quick Idea</button>
  <button class="tab" data-tab="baseball">‚öæ Baseball</button>
  <button class="tab" data-tab="favorites">‚≠ê Favorites<span class="tab-badge" id="favBadge" style="display:none;">0</span></button>
  <button class="tab" data-tab="history">üìú History</button>
  <button class="tab" data-tab="stats">üìä Stats</button>
  <button class="tab" data-tab="settings">‚öôÔ∏è Settings</button>
</div>

<!-- Generator Tab -->
<div class="tab-content active" id="generator">
  <div class="container">
    <div class="controls">
      <input id="titleInput" type="text" placeholder="Game title (optional)">
      <input id="descInput" type="text" placeholder="Short description (optional)">
      <button class="btn" id="generateBtn">Generate Ideas</button>
    </div>
    <div class="search-box">
      <input id="searchInput" type="text" placeholder="üîç Search ideas...">
    </div>
    <div class="calendar" id="calendar"></div>
    <div style="display:flex;gap:12px;justify-content:center;margin-top:20px;flex-wrap:wrap;">
      <button class="btn" id="downloadBtn">Download (.txt)</button>
      <button class="btn" id="downloadJsonBtn">Download (.json)</button>
      <button class="btn" id="downloadCsvBtn">Download (.csv)</button>
    </div>
  </div>
</div>

<!-- Quick Idea Tab -->
<div class="tab-content" id="quick">
  <div class="container">
    <div class="quick-idea-box">
      <h3>Get a Random Game Idea Instantly</h3>
      <button class="btn" id="quickGenerateBtn" style="margin-bottom:20px;">Generate Random Idea</button>
      <div id="quickIdeaDisplay" style="display:none;">
        <div class="idea-display">
          <div class="idea-title" id="quickTitle"></div>
          <div class="idea-desc" id="quickDesc"></div>
        </div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
          <button class="btn btn-small" id="quickFavoriteBtn">‚≠ê Favorite</button>
          <button class="btn btn-small" id="quickCopyBtn">üìã Copy</button>
          <button class="btn btn-small" id="quickShareBtn">üîó Share</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Baseball Game Tab -->
<div class="tab-content" id="baseball">
  <div class="container" style="max-width:1400px;">
    <!-- Game Mode Selection -->
    <div style="background:rgba(255,255,255,0.1); border-radius:16px; padding:20px; margin-bottom:20px; backdrop-filter:blur(10px);">
      <div style="margin-bottom:12px; font-size:14px; opacity:0.9;">GAME MODE</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn btn-small" id="modeComputer" data-mode="computer" style="background:linear-gradient(135deg, #c41e3a, #0d4f8c);">ü§ñ Computer Play</button>
        <button class="btn btn-small" id="modePitch" data-mode="pitch">‚öæ Pitch Only</button>
        <button class="btn btn-small" id="modeBat" data-mode="bat">üèè Bat Only</button>
        <button class="btn btn-small" id="modeFull" data-mode="full">üéÆ Full Play</button>
      </div>
    </div>
    
    <!-- Enhanced Scoreboard -->
    <div style="background:linear-gradient(135deg, #c41e3a, #0d4f8c); border-radius:16px; padding:20px; margin-bottom:20px; box-shadow:var(--shadow-lg);">
      <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:12px; margin-bottom:16px;">
        <div style="text-align:center; background:rgba(0,0,0,0.4); border-radius:12px; padding:16px;">
          <div style="font-size:12px; opacity:0.9; margin-bottom:6px;">VISITOR</div>
          <div style="font-size:24px; font-weight:800;" id="visitorName">YANKEES</div>
          <div style="font-size:40px; font-weight:800; margin-top:6px;" id="visitorScore">0</div>
          <div style="font-size:11px; opacity:0.8; margin-top:6px;" id="visitorHits">0 H</div>
        </div>
        <div style="text-align:center; background:rgba(0,0,0,0.4); border-radius:12px; padding:16px;">
          <div style="font-size:12px; opacity:0.9; margin-bottom:6px;">INNING</div>
          <div style="font-size:24px; font-weight:800;" id="inningDisplay">TOP 1</div>
          <div style="font-size:18px; margin-top:6px;" id="outsDisplay">0 OUTS</div>
          <div style="font-size:11px; opacity:0.8; margin-top:6px;" id="countDisplay">0-0</div>
        </div>
        <div style="text-align:center; background:rgba(0,0,0,0.4); border-radius:12px; padding:16px;">
          <div style="font-size:12px; opacity:0.9; margin-bottom:6px;">HOME</div>
          <div style="font-size:24px; font-weight:800; color:#c41e3a;" id="homeName">RED SOX</div>
          <div style="font-size:40px; font-weight:800; margin-top:6px; color:#c41e3a;" id="homeScore">0</div>
          <div style="font-size:11px; opacity:0.8; margin-top:6px;" id="homeHits">0 H</div>
        </div>
      </div>
      
      <!-- Bases Display -->
      <div style="display:flex; justify-content:center; gap:20px; margin-bottom:16px; padding:12px; background:rgba(0,0,0,0.3); border-radius:10px;">
        <div style="text-align:center;">
          <div style="font-size:11px; opacity:0.8; margin-bottom:4px;">1ST</div>
          <div id="base1" style="width:30px; height:30px; border-radius:50%; background:rgba(255,255,255,0.2); margin:0 auto; border:2px solid rgba(255,255,255,0.5);"></div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:11px; opacity:0.8; margin-bottom:4px;">2ND</div>
          <div id="base2" style="width:30px; height:30px; border-radius:50%; background:rgba(255,255,255,0.2); margin:0 auto; border:2px solid rgba(255,255,255,0.5);"></div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:11px; opacity:0.8; margin-bottom:4px;">3RD</div>
          <div id="base3" style="width:30px; height:30px; border-radius:50%; background:rgba(255,255,255,0.2); margin:0 auto; border:2px solid rgba(255,255,255,0.5);"></div>
        </div>
      </div>
      
      <!-- Controls -->
      <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        <button class="btn" id="pitchBtn" style="background:linear-gradient(135deg, #c41e3a, #0d4f8c); display:none;">‚öæ Pitch</button>
        <button class="btn" id="swingBtn" style="background:linear-gradient(135deg, #0d4f8c, #c41e3a); display:none;">üèè Swing</button>
        <button class="btn" id="nextPlayBtn" style="background:rgba(255,255,255,0.2);">Next Play</button>
        <button class="btn" id="resetGameBtn" style="background:rgba(255,255,255,0.2);">Reset Game</button>
      </div>
      
      <!-- Batting UI -->
      <div id="battingUI" style="display:none; margin-top:16px; padding:16px; background:rgba(0,0,0,0.3); border-radius:12px;">
        <div style="text-align:center; margin-bottom:12px;">
          <div style="font-size:14px; opacity:0.9; margin-bottom:8px;">Press SPACEBAR or Click SWING to hit</div>
          <div style="display:flex; justify-content:center; gap:20px; align-items:center;">
            <div style="font-size:48px;" id="swingIndicator">üëÅÔ∏è</div>
            <div style="width:200px; height:40px; background:rgba(255,255,255,0.1); border-radius:20px; position:relative; overflow:hidden;">
              <div id="swingPower" style="height:100%; background:linear-gradient(90deg, #0d4f8c, #c41e3a); width:0%; transition:width 0.1s;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 3D Canvas -->
    <div id="baseballCanvas" style="width:100%; height:600px; background:#0a5d0a; border-radius:16px; position:relative; overflow:hidden; box-shadow:var(--shadow-xl);"></div>
    
    <!-- Game Log -->
    <div style="margin-top:20px; background:rgba(255,255,255,0.08); border-radius:12px; padding:16px; backdrop-filter:blur(10px);">
      <div style="font-size:14px; opacity:0.9; margin-bottom:12px;">GAME LOG</div>
      <div id="gameLog" style="max-height:150px; overflow-y:auto; font-size:13px; line-height:1.6;"></div>
    </div>
  </div>
</div>

<!-- Favorites Tab -->
<div class="tab-content" id="favorites">
  <div class="container">
    <div class="search-box">
      <input id="favSearchInput" type="text" placeholder="üîç Search favorites...">
    </div>
    <div class="calendar" id="favoritesContainer"></div>
    <div id="favEmptyState" class="empty-state" style="display:none;">
      <div class="empty-state-icon">‚≠ê</div>
      <p>No favorites yet. Start favoriting ideas you love!</p>
    </div>
  </div>
</div>

<!-- History Tab -->
<div class="tab-content" id="history">
  <div class="container">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;flex-wrap:wrap;gap:12px;">
      <h3 style="margin:0;">Generation History</h3>
      <button class="btn btn-small" id="clearHistoryBtn">Clear History</button>
    </div>
    <div id="historyContainer"></div>
    <div id="historyEmptyState" class="empty-state" style="display:none;">
      <div class="empty-state-icon">üìú</div>
      <p>No generation history yet. Start generating ideas!</p>
    </div>
  </div>
</div>

<!-- Stats Tab -->
<div class="tab-content" id="stats">
  <div class="container">
    <h3 style="text-align:center;margin-bottom:24px;">Your Statistics</h3>
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Ideas Generated</div>
        <div class="stat-value" id="statTotal">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Favorite Ideas</div>
        <div class="stat-value" id="statFavorites">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Generations</div>
        <div class="stat-value" id="statGenerations">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Most Used Genre</div>
        <div class="stat-value" id="statGenre" style="font-size:20px;">-</div>
      </div>
    </div>
    <div style="margin-top:32px;text-align:center;">
      <button class="btn" id="refreshStatsBtn">Refresh Stats</button>
    </div>
  </div>
</div>

<!-- Settings Tab -->
<div class="tab-content" id="settings">
  <div class="container">
    <h3 style="text-align:center;margin-bottom:24px;">Settings</h3>
    <div class="settings-grid">
      <div class="setting-item">
        <label>Number of Days to Generate</label>
        <input type="number" id="settingDays" min="1" max="365" value="30">
      </div>
      <div class="setting-item">
        <label>Default Export Format</label>
        <select id="settingExport">
          <option value="txt">Text (.txt)</option>
          <option value="json">JSON (.json)</option>
          <option value="csv">CSV (.csv)</option>
        </select>
      </div>
      <div class="setting-item">
        <label>Auto-save to History</label>
        <select id="settingAutoSave">
          <option value="true">Yes</option>
          <option value="false">No</option>
        </select>
      </div>
      <div class="setting-item">
        <label>OpenAI API Key (for AI-powered ideas)</label>
        <input type="password" id="settingApiKey" placeholder="sk-..." style="width:100%;">
        <div style="font-size:12px;opacity:0.8;margin-top:8px;">Get your key at <a href="https://platform.openai.com/api-keys" target="_blank" style="color:#0b74d1;">platform.openai.com</a>. Leave empty for random generation.</div>
      </div>
      <div class="setting-item">
        <label>AI Model</label>
        <select id="settingAiModel">
          <option value="gpt-4o-mini">GPT-4o Mini (Fast & Affordable)</option>
          <option value="gpt-4o">GPT-4o (Best Quality)</option>
          <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Fastest)</option>
        </select>
      </div>
    </div>
    <div style="margin-top:24px;text-align:center;">
      <button class="btn" id="saveSettingsBtn">Save Settings</button>
      <button class="btn" id="resetSettingsBtn" style="margin-left:12px;">Reset to Defaults</button>
    </div>
  </div>
</div>

<!-- Modal -->
<div class="modal" id="modal">
  <div class="panel">
    <button class="close" id="closeModal">√ó</button>
    <div id="panelContent"></div>
    <button class="share-btn" id="shareBtn">Share</button>
    <button class="copy-btn" id="copyBtn">Copy</button>
  </div>
</div>

<!-- Loading -->
<div class="loadingOverlay" id="loading">
  <div class="loadingCard">
    <h3>Generating ideas</h3>
    <div class="loadingInfo" id="loadingSub">Preparing...</div>
    <div class="progress"><i id="progressBar"></i></div>
    <div class="loadingInfo" id="loadingPct">0%</div>
  </div>
</div>
</div>

<script>
function sleep(ms){return new Promise(res=>setTimeout(res,ms));}
function rand(arr){return arr[Math.floor(Math.random()*arr.length)];}

const genres=['RPG','Platformer','Horror','Roguelike','Shooter','Simulation','Strategy','Mystery','Rhythm','Adventure','Puzzle','Metroidvania','Action','Stealth','Card','Sandbox','City Builder','VR','AR','Narrative','Survival','Fantasy','Sci-Fi','Historical','Cyberpunk','Noir','Western','Post-Apocalyptic','Space','Comedy','Slice of Life'];
const gameSettings=['a floating sky city','a haunted carnival','a neon cyber-metro','a quiet mountain village','an underwater research base','a desert planet outpost','a post-war bunker','a futuristic Tokyo district','a cursed forest','a digital dream world','an abandoned theme park','a medieval academy','a crumbling megacity','a pirate skyship','a moon colony','a misty swamp town','a massive AI core','a gothic cathedral','a snowy tundra settlement','a sunken city of glass'];
const mechanics=['time-loop progression','deck-building choices','squad management','gravity-based puzzles','musical combat','resource crafting','turn-based tactics','stealth infiltration','dialogue branching','combat rhythm sync','shape-shifting abilities','ecosystem simulation','roguelike dungeons','card fusion system','emotion-based AI companions','multi-timeline switching','reputation diplomacy','building physics simulation','team synergy combos','shadow possession'];
const storyHooks=['you awaken with your memories rewritten','your twin controls your shadow self','a forgotten song reshapes reality','a virus spreads through dreams','you lead refugees across broken dimensions','your choices rewrite past events','a rival mirrors your every move','you must uncover who programmed your fate','a city runs on bottled emotions','you hunt your future self','time fractures each dawn','your world ends every midnight','an AI writes new laws daily','the moon vanishes every night','you rebuild a civilization from echoes','magic runs through sound frequencies'];

// Expanded keyword system - generates millions of combinations
const genreBase=['RPG','Platformer','Horror','Roguelike','Shooter','Simulation','Strategy','Mystery','Rhythm','Adventure','Puzzle','Metroidvania','Action','Stealth','Card','Sandbox','City Builder','VR','AR','Narrative','Survival','Fantasy','Sci-Fi','Historical','Cyberpunk','Noir','Western','Post-Apocalyptic','Space','Comedy','Slice of Life','Tactical','Racing','Fighting','Sports','Educational','Idle','Incremental','Tower Defense','MOBA','Battle Royale','MMO','RTS','Turn-Based','Real-Time','Co-op','Competitive','Casual','Hardcore','Indie','AAA','Retro','Modern','Futuristic','Medieval','Steampunk','Dieselpunk','Biopunk','Solarpunk','Atompunk','Clockpunk','Dungeon Crawler','Souls-like','Roguelite','Bullet Hell','Twin-Stick','Top-Down','Isometric','Side-Scrolling','First-Person','Third-Person','Open World','Linear','Procedural','Hand-Crafted','Narrative-Driven','Gameplay-Focused','Story-Rich','Character-Driven','World-Building','Exploration','Combat','Puzzle-Solving','Crafting','Building','Trading','Farming','Cooking','Fishing','Hunting','Gathering','Mining','Crafting','Alchemy','Enchanting','Taming','Breeding','Farming','Trading','Diplomacy','Warfare','Exploration','Discovery','Survival','Crafting','Building','Social','Multiplayer','Single-Player','Cooperative','Competitive','Asymmetric','Symmetric','Team-Based','Free-For-All','Battle','Arena','Campaign','Story Mode','Endless Mode','Challenge Mode','Time Attack','Speedrun','Completionist','Collectathon','Metroidvania','Souls-like','Roguelike','Roguelite','Procedural','Hand-Crafted','Narrative','Gameplay','Combat','Puzzle','Exploration','Crafting','Building','Trading','Social','Multiplayer','Single-Player'];
const settingBase=['floating sky city','haunted carnival','neon cyber-metro','quiet mountain village','underwater research base','desert planet outpost','post-war bunker','futuristic Tokyo district','cursed forest','digital dream world','abandoned theme park','medieval academy','crumbling megacity','pirate skyship','moon colony','misty swamp town','massive AI core','gothic cathedral','snowy tundra settlement','sunken city of glass','orbital station','dimensional rift','time-lost temple','quantum realm','neural network','data fortress','memory palace','dreamscape','nightmare dimension','void between worlds','celestial observatory','ancient library','forbidden archive','crystal cavern','lava forge','ice citadel','storm tower','lightning spire','thunder peak','wind valley','earth core','fire mountain','water temple','air sanctuary','spirit realm','shadow dimension','light domain','dark abyss','bright void','colorless void','rainbow bridge','prism palace','mirror maze','echo chamber','silence cathedral','sound garden','music hall','rhythm temple','harmony sanctuary','discord fortress','chaos realm','order citadel','balance tower','imbalance abyss','stability core','instability zone','reality anchor','unreality void','truth beacon','lie labyrinth','honor hall','dishonor pit','virtue temple','vice den','purity shrine','corruption nest','sanctity altar','profanity chamber','divinity throne','mortality grave','immortality fountain','eternity gate','temporality clock','spatiality portal','dimensionality rift','parallelity mirror','alternativity switch','mirrority reflection','twistity distortion','straightity path','curvity arc','linearity line','circularity circle','spirality spiral','fractality fractal','chaoticity chaos','orderity order','randomity random','determinity determination','freedomity freedom','boundity bound','unboundity unbound','limitedity limited','unlimitedity unlimited','finiteity finite','infiniteity infinite','reality real','virtuality virtual','digitality digital','analogity analog','organicity organic','syntheticity synthetic','naturality natural','artificiality artificial','livingity living','deadity dead','undeadity undead','immortality immortal','mortality mortal','temporality temporal','eternality eternal','briefity brief','lastingity lasting','momentarity momentary','permanity permanent','tempority temporary','fixedity fixed','fluidity fluid','solidity solid','liquidity liquid','gaseity gaseous','plasmaity plasma','energyity energy','matterity matter','antimatterity antimatter'];
const settingPrefixes=['a','an','the','your','this','that','an ancient','a forgotten','a lost','a hidden','a secret','a mysterious','a legendary','an abandoned','a ruined','a thriving','a bustling','a quiet','a peaceful','a war-torn','a post-apocalyptic','a pre-apocalyptic','a futuristic','a retro-futuristic','a cyberpunk','a steampunk','a dieselpunk','a biopunk','a solarpunk','a medieval','a modern','a contemporary','an alternate','a parallel','a mirror','a twisted','a corrupted','a purified','a transformed','a mutated','a evolved','a devolved','a hybrid','a fusion','a combination','a blend','a mix','a synthesis','a quantum','a temporal','a spatial','a dimensional','a parallel','an alternate','a mirror','a twisted','a corrupted','a purified','a transformed','a mutated','an evolved','a devolved','a hybrid','a fusion','a combination','a blend','a mix','a synthesis','a quantum','a temporal','a spatial','a dimensional','a parallel','an alternate','a mirror','a twisted','a corrupted','a purified','a transformed','a mutated','an evolved','a devolved','a hybrid','a fusion','a combination','a blend','a mix','a synthesis'];
const mechanicBase=['time-loop progression','deck-building choices','squad management','gravity-based puzzles','musical combat','resource crafting','turn-based tactics','stealth infiltration','dialogue branching','combat rhythm sync','shape-shifting abilities','ecosystem simulation','roguelike dungeons','card fusion system','emotion-based AI companions','multi-timeline switching','reputation diplomacy','building physics simulation','team synergy combos','shadow possession','quantum entanglement mechanics','dimensional phase shifting','temporal manipulation','spatial distortion combat','reality warping abilities','probability manipulation','causality reversal','entropy control','information warfare','data stream combat','neural link synchronization','consciousness transfer','memory reconstruction','emotion harvesting','thought projection','dream invasion','nightmare manifestation','reality anchor deployment','dimensional barrier creation','parallel world navigation','timeline branch selection','causal chain manipulation','butterfly effect amplification','quantum superposition combat','wave function collapse mechanics','observer effect utilization','uncertainty principle exploitation','quantum tunneling movement','entanglement communication','spooky action coordination','quantum teleportation','superposition state switching','interference pattern combat','coherence maintenance','decoherence weaponization','quantum measurement paradox','many-worlds navigation','quantum immortality mechanics','temporal causality loops','closed timelike curves','grandfather paradox resolution','bootstrap paradox mechanics','predestination paradox navigation','causal loop stabilization','temporal anchor points','chronological synchronization','time dilation combat','relativistic effects','gravitational time manipulation','spacetime curvature weapons','wormhole creation','black hole mechanics','white hole utilization','singularity navigation','event horizon manipulation','spacetime metric alteration','dimensional membrane crossing','brane world navigation','multiverse traversal','parallel universe hopping','alternate timeline exploration','mirror dimension access','pocket dimension creation','subspace navigation','hyperspace travel','warp drive mechanics','faster-than-light communication','tachyonic messaging','causality violation mechanics','temporal paradox resolution','chronological protection','time police mechanics','temporal enforcement','chronos guardian systems','time stream navigation','temporal current riding','chronological surfing','time wave manipulation','temporal resonance','chronological harmonics','time frequency tuning','temporal wavelength adjustment','chronological amplitude modulation','time phase shifting','temporal interference patterns','chronological standing waves','time harmonic resonance','temporal beat frequencies','chronological overtones','time fundamental frequencies','temporal harmonics generation','chronological frequency multiplication','time frequency division','temporal frequency mixing','chronological frequency modulation','time amplitude modulation','temporal phase modulation','chronological frequency shift keying','time amplitude shift keying','temporal phase shift keying','chronological quadrature amplitude modulation','time orthogonal frequency division','temporal code division multiple access','chronological time division multiple access','time frequency division multiple access','temporal space division multiple access','chronological code division multiple access','time wavelength division multiple access','temporal polarization division multiple access','chronological angle division multiple access','time direction division multiple access','temporal velocity division multiple access','chronological acceleration division multiple access','time momentum division multiple access','temporal energy division multiple access','chronological mass division multiple access','time charge division multiple access','temporal spin division multiple access','chronological angular momentum division multiple access','time magnetic moment division multiple access','temporal electric dipole moment division multiple access','chronological magnetic dipole moment division multiple access','time quadrupole moment division multiple access','temporal octupole moment division multiple access','chronological hexadecapole moment division multiple access','time 32-pole moment division multiple access','temporal 64-pole moment division multiple access','chronological 128-pole moment division multiple access','time 256-pole moment division multiple access','temporal 512-pole moment division multiple access','chronological 1024-pole moment division multiple access'];
const hookBase=['you awaken with your memories rewritten','your twin controls your shadow self','a forgotten song reshapes reality','a virus spreads through dreams','you lead refugees across broken dimensions','your choices rewrite past events','a rival mirrors your every move','you must uncover who programmed your fate','a city runs on bottled emotions','you hunt your future self','time fractures each dawn','your world ends every midnight','an AI writes new laws daily','the moon vanishes every night','you rebuild a civilization from echoes','magic runs through sound frequencies','quantum entanglement links your fate to another','dimensional rifts appear at random','time flows backwards in certain areas','reality glitches reveal hidden truths','parallel versions of yourself seek to merge','your consciousness exists in multiple bodies','memories from alternate timelines surface','the laws of physics change daily','gravity reverses every full moon','light travels at different speeds','matter phases between states randomly','energy manifests as visible entities','information becomes physical objects','data streams create physical structures','neural networks gain consciousness','AI entities achieve true sentience','machines develop emotions','robots experience dreams','computers fall in love','algorithms develop free will','code becomes self-aware','programs evolve into lifeforms','software mutates into organisms','hardware transforms into biology','circuits grow like plants','processors develop nervous systems','memory becomes sentient','storage gains consciousness','networks achieve awareness','connections develop intelligence','links become alive','paths gain sentience','routes develop consciousness','channels achieve awareness','streams gain intelligence','flows develop sentience','currents become conscious','waves achieve awareness','frequencies gain sentience','vibrations develop consciousness','oscillations achieve awareness','resonances gain intelligence','harmonics develop sentience','overtones become conscious','fundamentals achieve awareness','tones gain sentience','notes develop consciousness','chords achieve awareness','scales gain intelligence','keys develop sentience','modes become conscious','intervals achieve awareness','progressions gain sentience','cadences develop consciousness','resolutions achieve awareness','dissonances gain intelligence','consonances develop sentience','unisons become conscious','octaves achieve awareness','fifths gain sentience','fourths develop consciousness','thirds achieve awareness','seconds gain intelligence','sixths develop sentience','sevenths become conscious','ninths achieve awareness','tenths gain sentience','elevenths develop consciousness','thirteenths achieve awareness','fifteenths gain intelligence','seventeenths develop sentience','nineteenths become conscious','twenty-firsts achieve awareness','twenty-thirds gain sentience','twenty-fifths develop consciousness','twenty-sevenths achieve awareness','twenty-ninths gain intelligence','thirty-firsts develop sentience','thirty-thirds become conscious','thirty-fifths achieve awareness','thirty-sevenths gain sentience','thirty-ninths develop consciousness','forty-firsts achieve awareness','forty-thirds gain intelligence','forty-fifths develop sentience','forty-sevenths become conscious','forty-ninths achieve awareness','fifty-firsts gain sentience','fifty-thirds develop consciousness','fifty-fifths achieve awareness','fifty-sevenths gain intelligence','fifty-ninths develop sentience','sixty-firsts become conscious','sixty-thirds achieve awareness','sixty-fifths gain sentience','sixty-sevenths develop consciousness','sixty-ninths achieve awareness','seventy-firsts gain intelligence','seventy-thirds develop sentience','seventy-fifths become conscious','seventy-sevenths achieve awareness','seventy-ninths gain sentience','eighty-firsts develop consciousness','eighty-thirds achieve awareness','eighty-fifths gain intelligence','eighty-sevenths develop sentience','eighty-ninths become conscious','ninety-firsts achieve awareness','ninety-thirds gain sentience','ninety-fifths develop consciousness','ninety-sevenths achieve awareness','ninety-ninths gain intelligence'];

function getExpandedGenre(){return rand(genreBase);}
function getExpandedSetting(){return rand(settingPrefixes)+' '+rand(settingBase);}
function getExpandedMechanic(){return rand(mechanicBase);}
function getExpandedHook(){return rand(hookBase);}

// Storage helpers
function getStorage(key,defaultVal=[]){const v=localStorage.getItem(key);return v?JSON.parse(v):defaultVal;}
function setStorage(key,val){localStorage.setItem(key,JSON.stringify(val));}

// State
const appContainer = document.getElementById('appContainer');
const calendarEl=document.getElementById('calendar');
const modal=document.getElementById('modal');
const panel=document.getElementById('panelContent');
const copyBtn=document.getElementById('copyBtn');
const shareBtn=document.getElementById('shareBtn');
const closeModalBtn=document.getElementById('closeModal');
const logoBtn=document.getElementById('logoBtn');
const loading=document.getElementById('loading');
const progressBar=document.getElementById('progressBar');
const loadingPct=document.getElementById('loadingPct');
let currentIdeas=[];
let currentModalIdea=null;
let currentModalDay=0;

// Settings
let settings={days:30,export:'txt',autoSave:true,apiKey:'',aiModel:'gpt-4o-mini'};
function loadSettings(){const s=getStorage('settings',settings);settings={...settings,...s};}
function saveSettings(){setStorage('settings',settings);}
function applySettings(){
  const daysEl=document.getElementById('settingDays');
  const exportEl=document.getElementById('settingExport');
  const autoSaveEl=document.getElementById('settingAutoSave');
  const apiKeyEl=document.getElementById('settingApiKey');
  const aiModelEl=document.getElementById('settingAiModel');
  if(daysEl)daysEl.value=settings.days;
  if(exportEl)exportEl.value=settings.export;
  if(autoSaveEl)autoSaveEl.value=settings.autoSave.toString();
  if(apiKeyEl)apiKeyEl.value=settings.apiKey||'';
  if(aiModelEl)aiModelEl.value=settings.aiModel||'gpt-4o-mini';
}

// Tab switching
function initTabs(){
  document.querySelectorAll('.tab').forEach(tab=>{
    tab.onclick=()=>{
      document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(tab.dataset.tab).classList.add('active');
      if(tab.dataset.tab==='favorites')renderFavorites();
      if(tab.dataset.tab==='history')renderHistory();
      if(tab.dataset.tab==='stats')updateStats();
      if(tab.dataset.tab==='baseball'){
        setTimeout(()=>{
          const canvas=document.getElementById('baseballCanvas');
          if(canvas&&scene===null){
            initBaseballGame();
            updateScoreboard();
          }
        },100);
      }
    };
  });
}

// Initialize on load
window.addEventListener('load',()=>{
  loadSettings();
  applySettings();
  initTabs();
  appContainer.style.opacity='1';
  updateFavBadge();
  renderFavorites();
  renderHistory();
  updateStats();
});

// Modal
function fadeOutModal(){
  modal.style.opacity='0';
  setTimeout(()=>{modal.style.display='none';modal.classList.remove('visible');modal.style.opacity='';},500);
}
closeModalBtn.onclick=()=>fadeOutModal();
modal.onclick=e=>{if(e.target===modal)fadeOutModal();};

copyBtn.onclick=()=>{
  if(!currentModalIdea)return;
  const text=`${currentModalIdea.short}\n\n${currentModalIdea.explanation}`;
  navigator.clipboard.writeText(text).then(()=>{alert('Copied to clipboard!');});
};

shareBtn.onclick=()=>{
  if(!currentModalIdea)return;
  const text=`üéÆ Game Idea: ${currentModalIdea.short}\n\n${currentModalIdea.explanation}`;
  if(navigator.share){
    navigator.share({title:'Game Idea',text:text}).catch(()=>{});
  }else{
    navigator.clipboard.writeText(text).then(()=>{alert('Copied to clipboard!');});
  }
};

// Logo resets app
logoBtn.onclick = () => {
  appContainer.style.opacity='0';
  setTimeout(()=>{
    calendarEl.innerHTML='';
    currentIdeas=[];
    document.getElementById('titleInput').value='';
    document.getElementById('descInput').value='';
    document.getElementById('searchInput').value='';
    fadeOutModal();
    appContainer.style.opacity='1';
  },600);
};

async function showLoading(seconds,text){
  loading.style.display='flex';
  document.getElementById('loadingSub').textContent=text;
  progressBar.style.width='0%';
  loadingPct.textContent='0%';
  for(let i=1;i<=seconds;i++){
    progressBar.style.width=Math.min(100,Math.round(i/seconds*100))+'%';
    loadingPct.textContent=Math.min(100,Math.round(i/seconds*100))+'%';
    await sleep(200);
  }
}

async function generateAIIdea(title,desc){
  if(!settings.apiKey||!settings.apiKey.trim())return null;
  try{
    const prompt=`Generate a unique, creative game idea. ${title?`Title preference: "${title}". `:''}${desc?`Description: "${desc}". `:''}Return a JSON object with: {"genres":["genre1","genre2"],"setting":"unique game world","mechanic":"core gameplay mechanic","hook":"narrative premise","title":"game title","short":"brief one-line description","explanation":"detailed 2-3 sentence explanation"}. Be creative and original.`;
    const response=await fetch('https://api.openai.com/v1/chat/completions',{
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${settings.apiKey.trim()}`
      },
      body:JSON.stringify({
        model:settings.aiModel||'gpt-4o-mini',
        messages:[{role:'user',content:prompt}],
        temperature:0.9,
        max_tokens:300
      })
    });
    if(!response.ok)throw new Error('API error');
    const data=await response.json();
    const content=data.choices[0].message.content.trim();
    let idea;
    try{
      idea=JSON.parse(content);
    }catch{
      const jsonMatch=content.match(/\{[\s\S]*\}/);
      if(jsonMatch)idea=JSON.parse(jsonMatch[0]);
      else throw new Error('Invalid response format');
    }
    const genres=Array.isArray(idea.genres)?idea.genres:[idea.genres||'Adventure'];
    const short=`${genres.join(" / ")} ‚Äî Set in ${idea.setting||'a unique world'}. Core mechanic: ${idea.mechanic||'engaging gameplay'}. Story hook: ${idea.hook||'an intriguing premise'}. Title: "${idea.title||'Untitled Game'}".`;
    return {
      short:idea.short||short,
      explanation:idea.explanation||`This concept mixes ${genres.join(', ')} elements in ${idea.setting}. The core loop revolves around ${idea.mechanic}, and the main narrative tension is: ${idea.hook}. The name "${idea.title||'Untitled'}" ties the style and mood together.`,
      primary:genres[0],
      genres:genres,
      setting:idea.setting||'a unique world',
      mechanic:idea.mechanic||'engaging gameplay',
      hook:idea.hook||'an intriguing premise',
      title:idea.title||'Untitled Game',
      id:Date.now()+Math.random(),
      aiGenerated:true
    };
  }catch(err){
    console.error('AI generation error:',err);
    return null;
  }
}

function buildIdea(title, desc){
  const g=[getExpandedGenre(),getExpandedGenre(),getExpandedGenre()].filter((v,i,a)=>a.indexOf(v)===i).slice(0,rand([1,2,3]));
  const s=getExpandedSetting(); const m=getExpandedMechanic(); const h=getExpandedHook();
  const adjectives=["Crimson","Neon","Shadow","Silent","Echo","Phantom","Eternal","Crystal","Solar","Iron","Velvet","Dream","Infinite","Midnight","Azure","Golden","Arcane","Forgotten","Digital","Frozen","Titan","Spectral","Burning","Emerald","Void","Celestial","Primal","Ancient","Mystic","Ethereal","Cosmic","Quantum","Neon","Cyber","Bio","Nano","Hyper","Ultra","Mega","Super","Prime","Alpha","Omega","Zero","Null","Void","Dark","Light","Bright","Dim","Faded","Vibrant","Muted","Bold","Subtle","Raw","Refined","Pure","Corrupt","Sacred","Profane","Divine","Demonic","Heavenly","Infernal","Eternal","Temporal","Spatial","Dimensional","Parallel","Alternate","Mirror","Twisted","Straight","Curved","Linear","Circular","Spiral","Fractal","Chaotic","Ordered","Random","Determined","Free","Bound","Unbound","Limited","Unlimited","Finite","Infinite","Real","Virtual","Digital","Analog","Organic","Synthetic","Natural","Artificial","Living","Dead","Undead","Immortal","Mortal","Temporal","Eternal","Brief","Lasting","Momentary","Permanent","Temporary","Fixed","Fluid","Solid","Liquid","Gaseous","Plasma","Energy","Matter","Antimatter","Dark","Light","Bright","Dim","Luminous","Opaque","Transparent","Translucent","Visible","Invisible","Tangible","Intangible","Physical","Metaphysical","Material","Immaterial","Corporeal","Incorporeal","Solid","Hollow","Dense","Sparse","Thick","Thin","Wide","Narrow","Broad","Tight","Loose","Taut","Slack","Rigid","Flexible","Stiff","Supple","Hard","Soft","Firm","Gentle","Rough","Smooth","Coarse","Fine","Crude","Refined","Raw","Processed","Natural","Artificial","Organic","Inorganic","Living","Nonliving","Animate","Inanimate","Sentient","Insentient","Conscious","Unconscious","Aware","Unaware","Awake","Asleep","Alive","Dead","Undead","Immortal","Mortal","Eternal","Temporal","Infinite","Finite","Unlimited","Limited","Boundless","Bounded","Free","Restricted","Open","Closed","Accessible","Inaccessible","Available","Unavailable","Present","Absent","Here","There","Near","Far","Close","Distant","Local","Remote","Proximate","Distant","Adjacent","Separate","Connected","Disconnected","Linked","Unlinked","Joined","Separated","United","Divided","Whole","Partial","Complete","Incomplete","Finished","Unfinished","Done","Undone","Accomplished","Unaccomplished","Achieved","Unachieved","Succeeded","Failed","Won","Lost","Victorious","Defeated","Triumphant","Vanquished","Conquered","Unconquered","Dominant","Submissive","Powerful","Powerless","Strong","Weak","Mighty","Feeble","Robust","Fragile","Sturdy","Delicate","Tough","Tender","Hardy","Sensitive","Resilient","Vulnerable","Invulnerable","Indestructible","Destructible","Durable","Perishable","Lasting","Ephemeral","Permanent","Temporary","Enduring","Fleeting","Stable","Unstable","Steady","Unsteady","Firm","Unfirm","Solid","Unsolid","Secure","Insecure","Safe","Unsafe","Protected","Unprotected","Defended","Undefended","Guarded","Unguarded","Shielded","Unshielded","Armored","Unarmored","Fortified","Unfortified","Reinforced","Unreinforced","Strengthened","Weakened","Enhanced","Diminished","Improved","Deteriorated","Upgraded","Downgraded","Elevated","Lowered","Raised","Dropped","Lifted","Fallen","Ascended","Descended","Risen","Sunk","Floated","Sank","Soared","Plummeted","Climbed","Fell","Jumped","Landed","Leaped","Bounded","Sprung","Sprang","Bounced","Rebounded","Reflected","Refracted","Absorbed","Emitted","Radiated","Conducted","Insulated","Isolated","Connected","Disconnected","Linked","Unlinked","Joined","Separated","United","Divided","Merged","Split","Combined","Separated","Fused","Fissioned","Integrated","Disintegrated","Assembled","Disassembled","Constructed","Destroyed","Built","Demolished","Created","Annihilated","Formed","Deformed","Shaped","Misshapen","Molded","Unmolded","Carved","Uncarved","Sculpted","Unsculpted","Crafted","Uncrafted","Made","Unmade","Produced","Unproduced","Generated","Ungenerated","Manufactured","Unmanufactured","Fabricated","Unfabricated","Constructed","Deconstructed","Built","Unbuilt","Erected","Demolished","Raised","Razed","Established","Disestablished","Founded","Dissolved","Instituted","Abolished","Created","Destroyed","Formed","Deformed","Shaped","Misshapen","Molded","Unmolded","Carved","Uncarved","Sculpted","Unsculpted","Crafted","Uncrafted","Made","Unmade","Produced","Unproduced","Generated","Ungenerated","Manufactured","Unmanufactured","Fabricated","Unfabricated"];
  const nouns=["Odyssey","Protocol","Frontier","Legacy","Descent","Haven","Circuit","Genesis","Chronicle","Abyss","Empire","Horizon","Velocity","Tide","Sanctum","Hollow","Labyrinth","Catalyst","Pulse","Voyage","Realm","Shift","Beacon","Domain","Nexus","Vortex","Matrix","Grid","Network","System","Framework","Structure","Architecture","Design","Pattern","Template","Blueprint","Schema","Model","Prototype","Archetype","Paradigm","Exemplar","Standard","Benchmark","Criterion","Measure","Metric","Gauge","Scale","Range","Scope","Extent","Reach","Span","Width","Breadth","Depth","Height","Length","Distance","Proximity","Vicinity","Neighborhood","Region","Area","Zone","Territory","Domain","Realm","Kingdom","Empire","Nation","Country","State","Province","County","District","Precinct","Ward","Quarter","Section","Segment","Part","Portion","Fraction","Percentage","Ratio","Proportion","Share","Allotment","Quota","Allowance","Ration","Portion","Share","Part","Piece","Fragment","Segment","Section","Division","Subdivision","Category","Class","Type","Kind","Sort","Variety","Species","Genus","Family","Order","Phylum","Kingdom","Domain","Realm","Sphere","Orb","Globe","Ball","Circle","Ring","Loop","Coil","Spiral","Helix","Curve","Arc","Bend","Turn","Twist","Rotation","Revolution","Orbit","Path","Trajectory","Course","Route","Way","Road","Pathway","Track","Trail","Lane","Street","Avenue","Boulevard","Highway","Freeway","Expressway","Turnpike","Tollway","Causeway","Bridge","Overpass","Underpass","Tunnel","Subway","Metro","Railway","Railroad","Train","Locomotive","Engine","Motor","Machine","Device","Apparatus","Instrument","Tool","Implement","Utensil","Gadget","Contraption","Mechanism","Contrivance","Invention","Innovation","Creation","Product","Artifact","Object","Item","Thing","Entity","Being","Creature","Organism","Lifeform","Species","Specimen","Sample","Example","Instance","Case","Occurrence","Event","Incident","Episode","Scene","Act","Chapter","Section","Part","Segment","Division","Subdivision","Category","Class","Type","Kind","Sort","Variety","Species","Genus","Family","Order","Phylum","Kingdom","Domain","Realm","Sphere","Orb","Globe","Ball","Circle","Ring","Loop","Coil","Spiral","Helix","Curve","Arc","Bend","Turn","Twist","Rotation","Revolution","Orbit","Path","Trajectory","Course","Route","Way","Road","Pathway","Track","Trail","Lane","Street","Avenue","Boulevard","Highway","Freeway","Expressway","Turnpike","Tollway","Causeway","Bridge","Overpass","Underpass","Tunnel","Subway","Metro","Railway","Railroad","Train","Locomotive","Engine","Motor","Machine","Device","Apparatus","Instrument","Tool","Implement","Utensil","Gadget","Contraption","Mechanism","Contrivance","Invention","Innovation","Creation","Product","Artifact","Object","Item","Thing","Entity","Being","Creature","Organism","Lifeform","Species","Specimen","Sample","Example","Instance","Case","Occurrence","Event","Incident","Episode","Scene","Act","Chapter","Section","Part","Segment","Division","Subdivision","Category","Class","Type","Kind","Sort","Variety"];
  function smartTitleFrom(descText){
    const d=(descText||"").toLowerCase();
    if(d.includes("fun")||d.includes("happy"))return rand(["Joy Horizon","Color Quest","Happy Fields"]);
    if(d.includes("dark")||d.includes("scary")||d.includes("fear"))return rand(["Shadow Genesis","Phantom Descent","Eclipse Veil"]);
    if(d.includes("space")||d.includes("future")||d.includes("tech"))return rand(["Neon Frontier","Echo Circuit","Digital Odyssey"]);
    if(d.includes("magic")||d.includes("fantasy")||d.includes("mystic"))return rand(["Arcane Horizon","Crystal Haven","Forgotten Realm"]);
    if(d.includes("war")||d.includes("fight")||d.includes("battle"))return rand(["Iron Protocol","Crimson Empire","Tactical Horizon"]);
    return rand(adjectives)+" "+rand(nouns);
  }
  const focus=title?.trim()?title.trim():(desc?.trim()?smartTitleFrom(desc):smartTitleFrom(""));
  const short=`${g.join(" / ")} ‚Äî Set in ${s}. Core mechanic: ${m}. Story hook: ${h}. Title: "${focus}".`;
  const explanation=`This concept mixes ${g.join(', ')} elements in ${s}. The core loop revolves around ${m}, and the main narrative tension is: ${h}. The name "${focus}" ties the style and mood together for a cohesive creative theme.`;
  return {short,explanation,primary:g[0],genres:g,setting:s,mechanic:m,hook:h,title:focus,id:Date.now()+Math.random(),aiGenerated:false};
}

function createCard(idea,day,showFav=true){
  const card=document.createElement('div');
  card.className='card';
  card.dataset.ideaId=idea.id;
  const favs=getStorage('favorites',[]);
  const isFav=favs.some(f=>f.id===idea.id);
  card.style.background=`linear-gradient(180deg, #0b74d1, rgba(0,0,0,0.14))`;
  card.innerHTML=`<div class="num">${day?`Day ${day}`:'Idea'}</div><div class="short">${idea.short}</div><div class="tooltip">Click for details</div>${showFav?`<button class="btn-fav ${isFav?'favorited':''}" data-idea-id="${idea.id}">${isFav?'‚≠ê':'‚òÜ'}</button>`:''}`;
  card.onclick=(e)=>{if(!e.target.classList.contains('btn-fav'))openModal(idea,day);};
  if(showFav){
    const favBtn=card.querySelector('.btn-fav');
    favBtn.onclick=(e)=>{e.stopPropagation();toggleFavorite(idea);};
  }
  return card;
}

function openModal(idea,day){
  currentModalIdea=idea;
  currentModalDay=day;
  panel.innerHTML='';
  const h=document.createElement('h2');
  h.textContent=day?`Day ${day} ‚Äî ${idea.short}`:idea.short;
  const p=document.createElement('p');
  p.textContent=idea.explanation;
  panel.appendChild(h);
  panel.appendChild(p);
  modal.classList.add('visible');
  modal.style.display='flex';
}

function toggleFavorite(idea){
  let favs=getStorage('favorites',[]);
  const idx=favs.findIndex(f=>f.id===idea.id);
  if(idx>=0){
    favs.splice(idx,1);
    document.querySelectorAll(`[data-idea-id="${idea.id}"]`).forEach(btn=>{
      btn.classList.remove('favorited');
      btn.textContent='‚òÜ';
    });
  }else{
    favs.push(idea);
    document.querySelectorAll(`[data-idea-id="${idea.id}"]`).forEach(btn=>{
      btn.classList.add('favorited');
      btn.textContent='‚≠ê';
    });
  }
  setStorage('favorites',favs);
  updateFavBadge();
  if(document.getElementById('favorites').classList.contains('active'))renderFavorites();
}

function updateFavBadge(){
  const favs=getStorage('favorites',[]);
  const badge=document.getElementById('favBadge');
  if(favs.length>0){
    badge.textContent=favs.length;
    badge.style.display='flex';
  }else{
    badge.style.display='none';
  }
}

function renderFavorites(){
  const favs=getStorage('favorites',[]);
  const container=document.getElementById('favoritesContainer');
  const empty=document.getElementById('favEmptyState');
  container.innerHTML='';
  const searchTerm=document.getElementById('favSearchInput').value.toLowerCase();
  const filtered=favs.filter(f=>!searchTerm||f.short.toLowerCase().includes(searchTerm)||f.explanation.toLowerCase().includes(searchTerm));
  if(filtered.length===0){
    container.style.display='none';
    empty.style.display='block';
  }else{
    container.style.display='grid';
    empty.style.display='none';
    filtered.forEach((idea,i)=>{container.appendChild(createCard(idea,i+1,false));});
  }
}

function renderHistory(){
  const history=getStorage('history',[]);
  const container=document.getElementById('historyContainer');
  const empty=document.getElementById('historyEmptyState');
  container.innerHTML='';
  if(history.length===0){
    container.style.display='none';
    empty.style.display='block';
  }else{
    container.style.display='block';
    empty.style.display='none';
    history.reverse().forEach((entry,idx)=>{
      const div=document.createElement('div');
      div.style.background='rgba(255,255,255,0.08)';
      div.style.borderRadius='10px';
      div.style.padding='16px';
      div.style.marginBottom='12px';
      const date=new Date(entry.timestamp);
      div.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:start;flex-wrap:wrap;gap:12px;"><div><strong>${date.toLocaleString()}</strong><div style="font-size:13px;opacity:0.8;margin-top:4px;">${entry.count} ideas generated</div></div><button class="btn btn-small" onclick="loadHistoryEntry(${history.length-1-idx})">Load</button></div>`;
      container.appendChild(div);
    });
  }
}

window.loadHistoryEntry=(idx)=>{
  const history=getStorage('history',[]);
  const entry=history[history.length-1-idx];
  if(entry){
    currentIdeas=entry.ideas;
    calendarEl.innerHTML='';
    currentIdeas.forEach((idea,i)=>{
      calendarEl.appendChild(createCard(idea,i+1));
    });
    document.querySelector('[data-tab="generator"]').click();
  }
};

function updateStats(){
  const history=getStorage('history',[]);
  const favs=getStorage('favorites',[]);
  let totalIdeas=0;
  const genreCount={};
  history.forEach(h=>{
    totalIdeas+=h.ideas.length;
    h.ideas.forEach(i=>{
      if(i.genres) i.genres.forEach(g=>{genreCount[g]=(genreCount[g]||0)+1;});
    });
  });
  document.getElementById('statTotal').textContent=totalIdeas;
  document.getElementById('statFavorites').textContent=favs.length;
  document.getElementById('statGenerations').textContent=history.length;
  const topGenre=Object.keys(genreCount).reduce((a,b)=>genreCount[a]>genreCount[b]?a:b,'-');
  document.getElementById('statGenre').textContent=topGenre;
}

async function generateAndRender(){
  const title=document.getElementById('titleInput').value;
  const desc=document.getElementById('descInput').value;
  const numDays=parseInt(settings.days)||30;
  const useAI=settings.apiKey&&settings.apiKey.trim();
  await showLoading(useAI?Math.max(2,numDays*0.5):Math.max(1,1),"Preparing your ideas...");
  loading.classList.add('hidden');
  await sleep(300);
  loading.style.display='none';
  loading.classList.remove('hidden');
  calendarEl.innerHTML='';
  currentIdeas=[];
  document.getElementById('loadingSub').textContent=useAI?'Generating AI-powered ideas...':'Generating ideas...';
  for(let i=0;i<numDays;i++){
    let idea;
    if(useAI){
      document.getElementById('loadingSub').textContent=`Generating idea ${i+1}/${numDays} with AI...`;
      idea=await generateAIIdea(title,desc);
      if(!idea)idea=buildIdea(title,desc);
    }else{
      idea=buildIdea(title,desc);
    }
    currentIdeas.push(idea);
    calendarEl.appendChild(createCard(idea,i+1));
    await sleep(useAI?200:10);
  }
  if(settings.autoSave){
    const history=getStorage('history',[]);
    history.push({timestamp:Date.now(),ideas:currentIdeas,count:currentIdeas.length,title,desc,aiUsed:useAI});
    if(history.length>50)history.shift();
    setStorage('history',history);
  }
  updateStats();
}

// Search
document.getElementById('searchInput').addEventListener('input',(e)=>{
  const term=e.target.value.toLowerCase();
  document.querySelectorAll('#calendar .card').forEach(card=>{
    const text=card.textContent.toLowerCase();
    card.style.display=!term||text.includes(term)?'block':'none';
  });
});

document.getElementById('favSearchInput').addEventListener('input',()=>{renderFavorites();});

// Quick Idea
document.getElementById('quickGenerateBtn').onclick=async ()=>{
  const btn=document.getElementById('quickGenerateBtn');
  btn.disabled=true;
  btn.textContent='Generating...';
  let idea;
  if(settings.apiKey&&settings.apiKey.trim()){
    const aiIdea=await generateAIIdea('','');
    idea=aiIdea||buildIdea('','');
  }else{
    idea=buildIdea('','');
  }
  document.getElementById('quickTitle').textContent=idea.short;
  document.getElementById('quickDesc').textContent=idea.explanation;
  document.getElementById('quickIdeaDisplay').style.display='block';
  const favBtn=document.getElementById('quickFavoriteBtn');
  const favs=getStorage('favorites',[]);
  const isFav=favs.some(f=>f.id===idea.id);
  favBtn.textContent=isFav?'‚≠ê Unfavorite':'‚≠ê Favorite';
  favBtn.onclick=()=>{toggleFavorite(idea);favBtn.textContent=favs.some(f=>f.id===idea.id)?'‚≠ê Unfavorite':'‚≠ê Favorite';};
  document.getElementById('quickCopyBtn').onclick=()=>{
    navigator.clipboard.writeText(`${idea.short}\n\n${idea.explanation}`).then(()=>{alert('Copied!');});
  };
  document.getElementById('quickShareBtn').onclick=()=>{
    const text=`üéÆ Game Idea: ${idea.short}\n\n${idea.explanation}`;
    if(navigator.share){
      navigator.share({title:'Game Idea',text:text}).catch(()=>{});
    }else{
      navigator.clipboard.writeText(text).then(()=>{alert('Copied to clipboard!');});
    }
  };
  btn.disabled=false;
  btn.textContent='Generate Random Idea';
};

// Export functions
document.getElementById('downloadBtn').onclick=()=>{
  if(!currentIdeas.length){alert('Generate ideas first');return;}
  let txt='A Game a Day ‚Äî Ultra AI Edition\n\n';
  currentIdeas.forEach((it,i)=>{txt+=`Day ${i+1}:\n${it.short}\n${it.explanation}\n\n`;});
  const blob=new Blob([txt],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='a_game_a_day_ideas.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};

document.getElementById('downloadJsonBtn').onclick=()=>{
  if(!currentIdeas.length){alert('Generate ideas first');return;}
  const json=JSON.stringify(currentIdeas,null,2);
  const blob=new Blob([json],{type:'application/json'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='a_game_a_day_ideas.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};

document.getElementById('downloadCsvBtn').onclick=()=>{
  if(!currentIdeas.length){alert('Generate ideas first');return;}
  let csv='Day,Short Description,Full Explanation\n';
  currentIdeas.forEach((it,i)=>{csv+=`${i+1},"${it.short.replace(/"/g,'""')}","${it.explanation.replace(/"/g,'""')}"\n`;});
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='a_game_a_day_ideas.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
};

// Settings
document.getElementById('saveSettingsBtn').onclick=()=>{
  settings.days=parseInt(document.getElementById('settingDays').value)||30;
  settings.export=document.getElementById('settingExport').value;
  settings.autoSave=document.getElementById('settingAutoSave').value==='true';
  settings.apiKey=document.getElementById('settingApiKey').value;
  settings.aiModel=document.getElementById('settingAiModel').value;
  saveSettings();
  alert('Settings saved!');
};

document.getElementById('resetSettingsBtn').onclick=()=>{
  settings={days:30,export:'txt',autoSave:true};
  applySettings();
  saveSettings();
  alert('Settings reset!');
};

document.getElementById('refreshStatsBtn').onclick=()=>{updateStats();};

document.getElementById('clearHistoryBtn').onclick=()=>{
  if(confirm('Clear all generation history?')){
    setStorage('history',[]);
    renderHistory();
    updateStats();
  }
};

document.getElementById('generateBtn').onclick=generateAndRender;

// Baseball Game
let scene = null, camera = null, renderer = null, field = null, pitcher = null, batter = null, bat = null, ball = null;
let gameMode = 'computer'; // computer, pitch, bat, full
let swingPower = 0;
let swingCharging = false;
let ballInFlight = false;
let swingTiming = null;
let currentPitch = null;
let computerPlayInterval = null;

let gameState = {
  inning: 1,
  topInning: true,
  outs: 0,
  visitorScore: 0,
  homeScore: 0,
  visitorHits: 0,
  homeHits: 0,
  bases: [false, false, false],
  ballPosition: null,
  ballInFlight: false,
  strikes: 0,
  balls: 0,
  waitingForSwing: false
};

function initBaseballGame() {
  const canvas = document.getElementById('baseballCanvas');
  if (!canvas) return;
  
  // Check if Three.js is loaded
  if (typeof THREE === 'undefined') {
    console.error('Three.js is not loaded. Please check your internet connection.');
    canvas.innerHTML = '<div style="padding: 40px; text-align: center; color: white;">Error: Three.js library failed to load. Please check your internet connection and refresh the page.</div>';
    return;
  }

  // Scene setup
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a5d0a); // Green grass color
  scene.fog = new THREE.Fog(0x0a5d0a, 200, 500);

  // Camera setup - hyperrealistic close-up broadcast view
  camera = new THREE.PerspectiveCamera(35, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(0, 20, 35); // Close but ensure field is visible
  camera.lookAt(0, 0, -20); // Look toward pitcher/infield

  // Renderer with enhanced settings
  renderer = new THREE.WebGLRenderer({ 
    antialias: true,
    powerPreference: "high-performance",
    stencil: false,
    depth: true
  });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  canvas.appendChild(renderer.domElement);

  // Advanced lighting setup
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  
  // Main directional light (sun)
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
  sunLight.position.set(50, 120, 50);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 500;
  sunLight.shadow.camera.left = -100;
  sunLight.shadow.camera.right = 100;
  sunLight.shadow.camera.top = 100;
  sunLight.shadow.camera.bottom = -100;
  sunLight.shadow.bias = -0.0001;
  scene.add(sunLight);
  
  // Fill light
  const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
  fillLight.position.set(-30, 60, -30);
  scene.add(fillLight);
  
  // Rim light for dramatic effect
  const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
  rimLight.position.set(0, 20, 100);
  scene.add(rimLight);
  
  // Hemisphere light for sky
  const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x8b7355, 0.3);
  scene.add(hemiLight);

  // Create field
  createField();
  
  // Create all players
  try {
    createPlayers();
    if (typeof createFieldingPositions === 'function') {
      createFieldingPositions();
    }
    if (typeof createDugouts === 'function') {
      createDugouts();
    }
  } catch(e) {
    console.error('Error creating players:', e);
  }

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  });

  // Initial render
  animate();
}

function createGrassTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  
  // Base green
  ctx.fillStyle = '#0a5d0a';
  ctx.fillRect(0, 0, 512, 512);
  
  // Add grass pattern
  for (let i = 0; i < 5000; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 512;
    const hue = 90 + Math.random() * 30 - 15;
    const lightness = 20 + Math.random() * 10;
    ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
    ctx.fillRect(x, y, 2, 2);
  }
  
  // Add mowing pattern
  for (let y = 0; y < 512; y += 8) {
    ctx.strokeStyle = `rgba(0, 100, 0, 0.1)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(512, y);
    ctx.stroke();
  }
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(20, 20);
  return texture;
}

function createField() {
  // Realistic grass with texture
  const grass = new THREE.PlaneGeometry(200, 200, 50, 50);
  const grassTexture = createGrassTexture();
  const grassMat = new THREE.MeshStandardMaterial({ 
    map: grassTexture,
    color: 0x0a5d0a,
    roughness: 0.9,
    metalness: 0.0
  });
  const grassMesh = new THREE.Mesh(grass, grassMat);
  grassMesh.rotation.x = -Math.PI / 2;
  grassMesh.position.y = 0;
  grassMesh.receiveShadow = true;
  
  // Add slight displacement for realism
  const positions = grassMesh.geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    const z = positions.getZ(i);
    const x = positions.getX(i);
    const offset = (Math.sin(x * 0.1) + Math.cos(z * 0.1)) * 0.05;
    positions.setY(i, offset);
  }
  positions.needsUpdate = true;
  grassMesh.geometry.computeVertexNormals();
  
  scene.add(grassMesh);

  // Realistic infield dirt
  const dirtGeo = new THREE.CircleGeometry(35, 64);
  const dirtTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(0, 0, 256, 256);
    for (let i = 0; i < 2000; i++) {
      const x = Math.random() * 256;
      const y = Math.random() * 256;
      const brightness = 100 + Math.random() * 50;
      ctx.fillStyle = `rgb(${brightness * 0.5}, ${brightness * 0.3}, ${brightness * 0.2})`;
      ctx.fillRect(x, y, 1, 1);
    }
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(3, 3);
    return texture;
  })();
  const dirtMat = new THREE.MeshStandardMaterial({ 
    map: dirtTexture,
    color: 0x8b4513,
    roughness: 0.95,
    metalness: 0.0
  });
  const dirtMesh = new THREE.Mesh(dirtGeo, dirtMat);
  dirtMesh.rotation.x = -Math.PI / 2;
  dirtMesh.position.y = 0.02;
  dirtMesh.receiveShadow = true;
  scene.add(dirtMesh);

  // Realistic bases with texture
  const baseTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 128, 128);
    // Add fabric texture
    for (let i = 0; i < 500; i++) {
      const x = Math.random() * 128;
      const y = Math.random() * 128;
      ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.3})`;
      ctx.fillRect(x, y, 2, 2);
    }
    return new THREE.CanvasTexture(canvas);
  })();
  const baseMat = new THREE.MeshStandardMaterial({ 
    map: baseTexture,
    color: 0xffffff,
    roughness: 0.8,
    metalness: 0.1
  });
  
  // Home plate (pentagon shape)
  const homePlateShape = new THREE.Shape();
  homePlateShape.moveTo(0, 0);
  homePlateShape.lineTo(-0.43, 0.25);
  homePlateShape.lineTo(-0.43, -0.25);
  homePlateShape.lineTo(0, -0.5);
  homePlateShape.lineTo(0.43, -0.25);
  homePlateShape.lineTo(0.43, 0.25);
  homePlateShape.lineTo(0, 0);
  const homePlateGeo = new THREE.ExtrudeGeometry(homePlateShape, { depth: 0.15, bevelEnabled: false });
  const homePlate = new THREE.Mesh(homePlateGeo, baseMat);
  homePlate.rotation.x = -Math.PI / 2;
  homePlate.position.set(0, 0.15, 0);
  homePlate.scale.set(7, 7, 1);
  homePlate.castShadow = true;
  homePlate.receiveShadow = true;
  scene.add(homePlate);
  
  // First base (rounded)
  const firstBaseGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.15, 16);
  const firstBase = new THREE.Mesh(firstBaseGeo, baseMat);
  firstBase.rotation.x = Math.PI / 2;
  firstBase.position.set(27.4, 0.15, 27.4);
  firstBase.castShadow = true;
  firstBase.receiveShadow = true;
  scene.add(firstBase);
  
  // Second base
  const secondBase = new THREE.Mesh(firstBaseGeo.clone(), baseMat);
  secondBase.rotation.x = Math.PI / 2;
  secondBase.position.set(0, 0.15, 38.8);
  secondBase.castShadow = true;
  secondBase.receiveShadow = true;
  scene.add(secondBase);
  
  // Third base
  const thirdBase = new THREE.Mesh(firstBaseGeo.clone(), baseMat);
  thirdBase.rotation.x = Math.PI / 2;
  thirdBase.position.set(-27.4, 0.15, 27.4);
  thirdBase.castShadow = true;
  thirdBase.receiveShadow = true;
  scene.add(thirdBase);

  // Realistic pitcher's mound
  const moundGeo = new THREE.CylinderGeometry(3, 3, 0.3, 64);
  const moundTexture = dirtTexture.clone();
  const moundMat = new THREE.MeshStandardMaterial({ 
    map: moundTexture,
    color: 0x8b7355,
    roughness: 0.95,
    metalness: 0.0
  });
  const moundMesh = new THREE.Mesh(moundGeo, moundMat);
  moundMesh.position.set(0, 0.15, -18.4);
  moundMesh.castShadow = true;
  moundMesh.receiveShadow = true;
  scene.add(moundMesh);
  
  // Rubber plate on mound
  const rubberGeo = new THREE.BoxGeometry(0.6, 0.05, 0.24);
  const rubberMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
  const rubber = new THREE.Mesh(rubberGeo, rubberMat);
  rubber.position.set(0, 0.32, -18.4);
  rubber.castShadow = true;
  scene.add(rubber);

  // Realistic base paths (lines)
  const pathMat = new THREE.MeshStandardMaterial({ 
    color: 0xffffff,
    roughness: 0.3,
    metalness: 0.2,
    emissive: 0xffffff,
    emissiveIntensity: 0.1
  });
  const pathWidth = 0.12;
  const pathHeight = 0.06;

  // First base line
  const path1 = new THREE.BoxGeometry(40, pathHeight, pathWidth);
  const path1Mesh = new THREE.Mesh(path1, pathMat);
  path1Mesh.position.set(13.7, 0.025, 13.7);
  path1Mesh.rotation.y = Math.PI / 4;
  scene.add(path1Mesh);

  // Second base line
  const path2 = new THREE.BoxGeometry(40, pathHeight, pathWidth);
  const path2Mesh = new THREE.Mesh(path2, pathMat);
  path2Mesh.position.set(0, 0.025, 33);
  path2Mesh.rotation.y = Math.PI / 2;
  scene.add(path2Mesh);

  // Third base line
  const path3 = new THREE.BoxGeometry(40, pathHeight, pathWidth);
  const path3Mesh = new THREE.Mesh(path3, pathMat);
  path3Mesh.position.set(-13.7, 0.025, 13.7);
  path3Mesh.rotation.y = -Math.PI / 4;
  scene.add(path3Mesh);

  // Home to first
  const path4 = new THREE.BoxGeometry(40, pathHeight, pathWidth);
  const path4Mesh = new THREE.Mesh(path4, pathMat);
  path4Mesh.position.set(13.7, 0.025, 13.7);
  path4Mesh.rotation.y = Math.PI / 4;
  scene.add(path4Mesh);

  // Realistic outfield wall
  const wallTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, 512, 256);
    // Add wall texture
    for (let y = 0; y < 256; y += 8) {
      ctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(512, y);
      ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
  })();
  wallTexture.wrapS = THREE.RepeatWrapping;
  wallTexture.wrapT = THREE.RepeatWrapping;
  wallTexture.repeat.set(5, 2);
  
  const wallMat = new THREE.MeshStandardMaterial({ 
    map: wallTexture,
    color: 0x2a2a2a,
    roughness: 0.7,
    metalness: 0.1
  });
  const wall = new THREE.BoxGeometry(140, 10, 3);
  const wallMesh = new THREE.Mesh(wall, wallMat);
  wallMesh.position.set(0, 5, -95);
  wallMesh.castShadow = true;
  wallMesh.receiveShadow = true;
  scene.add(wallMesh);
  
  // Add padding on wall
  const paddingGeo = new THREE.BoxGeometry(140, 1, 0.5);
  const paddingMat = new THREE.MeshStandardMaterial({ 
    color: 0xffff00,
    roughness: 0.3,
    emissive: 0xffff00,
    emissiveIntensity: 0.3
  });
  const padding = new THREE.Mesh(paddingGeo, paddingMat);
  padding.position.set(0, 10.5, -95);
  scene.add(padding);
  
  // Stadium stands in background
  const standsGeo = new THREE.BoxGeometry(200, 40, 5);
  const standsTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, 512, 256);
    // Add crowd pattern
    for (let i = 0; i < 10000; i++) {
      const x = Math.random() * 512;
      const y = Math.random() * 256;
      const hue = Math.random() > 0.7 ? 0 : Math.random() * 360;
      ctx.fillStyle = `hsl(${hue}, 70%, ${30 + Math.random() * 40}%)`;
      ctx.fillRect(x, y, 2, 3);
    }
    return new THREE.CanvasTexture(canvas);
  })();
  standsTexture.wrapS = THREE.RepeatWrapping;
  standsTexture.wrapT = THREE.RepeatWrapping;
  standsTexture.repeat.set(3, 2);
  
  const standsMat = new THREE.MeshStandardMaterial({ 
    map: standsTexture,
    color: 0x3a3a3a,
    roughness: 0.8,
    metalness: 0.0
  });
  const stands = new THREE.Mesh(standsGeo, standsMat);
  stands.position.set(0, 25, -110);
  stands.rotation.x = -0.1;
  scene.add(stands);
  
  // Add dugouts
  const dugoutGeo = new THREE.BoxGeometry(15, 3, 8);
  const dugoutMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6 });
  const dugout1 = new THREE.Mesh(dugoutGeo, dugoutMat);
  dugout1.position.set(40, 1.5, 15);
  scene.add(dugout1);
  const dugout2 = new THREE.Mesh(dugoutGeo, dugoutMat);
  dugout2.position.set(-40, 1.5, 15);
  scene.add(dugout2);
  
  // Foul poles
  const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 25, 8);
  const poleMat = new THREE.MeshStandardMaterial({ 
    color: 0xffff00,
    emissive: 0xffff00,
    emissiveIntensity: 0.5
  });
  const pole1 = new THREE.Mesh(poleGeo, poleMat);
  pole1.position.set(60, 12.5, -95);
  scene.add(pole1);
  const pole2 = new THREE.Mesh(poleGeo, poleMat);
  pole2.position.set(-60, 12.5, -95);
  scene.add(pole2);
}

function createSkinTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const baseColor = '#ffdbac';
  ctx.fillStyle = baseColor;
  ctx.fillRect(0, 0, 128, 128);
  
  // Add skin variation
  for (let i = 0; i < 300; i++) {
    const x = Math.random() * 128;
    const y = Math.random() * 128;
    const brightness = 200 + Math.random() * 55;
    ctx.fillStyle = `rgb(${brightness}, ${brightness * 0.85}, ${brightness * 0.7})`;
    ctx.fillRect(x, y, 2, 2);
  }
  
  return new THREE.CanvasTexture(canvas);
}

function createUniformTexture(color) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  const rgb = parseInt(color.replace('#', ''), 16);
  const r = (rgb >> 16) & 0xff;
  const g = (rgb >> 8) & 0xff;
  const b = rgb & 0xff;
  
  ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
  ctx.fillRect(0, 0, 128, 128);
  
  // Add fabric texture
  for (let i = 0; i < 200; i++) {
    const x = Math.random() * 128;
    const y = Math.random() * 128;
    const variation = 20;
    ctx.fillStyle = `rgb(${Math.max(0, r - variation + Math.random() * variation * 2)}, ${Math.max(0, g - variation + Math.random() * variation * 2)}, ${Math.max(0, b - variation + Math.random() * variation * 2)})`;
    ctx.fillRect(x, y, 1, 1);
  }
  
  return new THREE.CanvasTexture(canvas);
}

function createHumanFigure(uniformColor, position, rotationY = 0, isPitcher = false) {
  const group = new THREE.Group();
  const skinTex = createSkinTexture();
  const uniformTex = createUniformTexture(uniformColor);
  
  // Hyperrealistic head with proper proportions
  const headGeo = new THREE.SphereGeometry(0.22, 32, 32);
  // More realistic head shape - slightly elongated
  headGeo.scale(0.85, 1.15, 0.9);
  const headMat = new THREE.MeshStandardMaterial({ 
    map: skinTex,
    color: 0xffdbac,
    roughness: 0.75,
    metalness: 0.0
  });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.72;
  group.add(head);
  
  // Realistic baseball helmet
  const helmetGeo = new THREE.SphereGeometry(0.24, 24, 24);
  helmetGeo.scale(0.9, 0.7, 0.95);
  const helmetTexture = createUniformTexture(isPitcher ? '#0d4f8c' : '#c41e3a');
  const helmetMat = new THREE.MeshStandardMaterial({ 
    map: helmetTexture,
    color: isPitcher ? 0x0d4f8c : 0xc41e3a,
    roughness: 0.25,
    metalness: 0.8,
    emissive: 0x000000,
    emissiveIntensity: 0
  });
  const helmet = new THREE.Mesh(helmetGeo, helmetMat);
  helmet.position.y = 1.88;
  helmet.rotation.x = 0.15;
  group.add(helmet);
  
  // Helmet visor
  const visorGeo = new THREE.BoxGeometry(0.4, 0.02, 0.25);
  const visorMat = new THREE.MeshStandardMaterial({ 
    color: 0x000000,
    roughness: 0.1,
    metalness: 0.9,
    transparent: true,
    opacity: 0.3
  });
  const visor = new THREE.Mesh(visorGeo, visorMat);
  visor.position.set(0, 1.78, 0.15);
  visor.rotation.x = -0.4;
  group.add(visor);
  
  // Realistic neck
  const neckGeo = new THREE.CylinderGeometry(0.09, 0.11, 0.2, 16);
  const neckMat = new THREE.MeshStandardMaterial({ 
    map: skinTex,
    color: 0xffdbac,
    roughness: 0.75
  });
  const neck = new THREE.Mesh(neckGeo, neckMat);
  neck.position.y = 1.58;
  group.add(neck);
  
  // Hyperrealistic torso with athletic build
  const torsoGeo = new THREE.BoxGeometry(0.5, 0.75, 0.35);
  const torsoMat = new THREE.MeshStandardMaterial({ 
    map: uniformTex,
    color: uniformColor,
    roughness: 0.65,
    metalness: 0.0
  });
  const torso = new THREE.Mesh(torsoGeo, torsoMat);
  torso.position.y = 1.08;
  group.add(torso);
  
  // Shoulders (more defined)
  const shoulderGeo = new THREE.SphereGeometry(0.22, 16, 16);
  const shoulderMat = new THREE.MeshStandardMaterial({ 
    map: uniformTex,
    color: uniformColor,
    roughness: 0.6
  });
  const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
  leftShoulder.position.set(-0.35, 1.35, 0);
  group.add(leftShoulder);
  const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
  rightShoulder.position.set(0.35, 1.35, 0);
  group.add(rightShoulder);
  
  // Hyperrealistic upper arms (athletic proportions)
  const upperArmGeo = new THREE.CylinderGeometry(0.1, 0.11, 0.35, 16);
  const armMat = new THREE.MeshStandardMaterial({ 
    map: uniformTex,
    color: uniformColor,
    roughness: 0.65
  });
  
  const leftUpperArm = new THREE.Mesh(upperArmGeo, armMat);
  leftUpperArm.position.set(-0.38, 1.02, 0);
  leftUpperArm.rotation.z = isPitcher ? -0.3 : 0.3;
  group.add(leftUpperArm);
  
  const rightUpperArm = new THREE.Mesh(upperArmGeo, armMat);
  rightUpperArm.position.set(0.38, 1.02, 0);
  rightUpperArm.rotation.z = isPitcher ? 0.3 : -0.3;
  group.add(rightUpperArm);
  
  // Realistic forearms
  const forearmGeo = new THREE.CylinderGeometry(0.085, 0.095, 0.3, 16);
  
  const leftForearm = new THREE.Mesh(forearmGeo, armMat);
  leftForearm.position.set(-0.52, 0.78, 0);
  leftForearm.rotation.z = isPitcher ? -0.5 : 0.5;
  group.add(leftForearm);
  
  const rightForearm = new THREE.Mesh(forearmGeo, armMat);
  rightForearm.position.set(0.52, 0.78, 0);
  rightForearm.rotation.z = isPitcher ? 0.5 : -0.5;
  group.add(rightForearm);
  
  // Realistic hands with glove
  const handGeo = new THREE.BoxGeometry(0.12, 0.18, 0.1);
  const handMat = new THREE.MeshStandardMaterial({ 
    map: skinTex,
    color: 0xffdbac,
    roughness: 0.75
  });
  
  const leftHand = new THREE.Mesh(handGeo, handMat);
  leftHand.position.set(-0.56, 0.60, 0);
  group.add(leftHand);
  
  const rightHand = new THREE.Mesh(handGeo, handMat);
  rightHand.position.set(0.56, 0.60, 0);
  group.add(rightHand);
  
  // Baseball glove on left hand
  const gloveGeo = new THREE.BoxGeometry(0.15, 0.22, 0.18);
  const gloveMat = new THREE.MeshStandardMaterial({ 
    color: 0x8b4513,
    roughness: 0.5,
    metalness: 0.1
  });
  const glove = new THREE.Mesh(gloveGeo, gloveMat);
  glove.position.set(-0.56, 0.60, 0.05);
  group.add(glove);
  
  // Hyperrealistic legs (athletic proportions)
  const legTex = createUniformTexture('#1a1a1a');
  const legGeo = new THREE.CylinderGeometry(0.12, 0.14, 0.85, 16);
  const legMat = new THREE.MeshStandardMaterial({ 
    map: legTex,
    color: 0x1a1a1a,
    roughness: 0.75,
    metalness: 0.0
  });
  
  const leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.18, 0.35, 0);
  group.add(leftLeg);
  
  const rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(0.18, 0.35, 0);
  group.add(rightLeg);
  
  // Realistic baseball cleats
  const shoeGeo = new THREE.BoxGeometry(0.25, 0.15, 0.35);
  const shoeTex = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 64, 64);
    // Add cleat texture
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * 64;
      const y = Math.random() * 64;
      ctx.fillStyle = `rgba(50, 50, 50, ${0.3 + Math.random() * 0.3})`;
      ctx.fillRect(x, y, 1, 1);
    }
    return new THREE.CanvasTexture(canvas);
  })();
  const shoeMat = new THREE.MeshStandardMaterial({ 
    map: shoeTex,
    color: 0x000000,
    roughness: 0.5,
    metalness: 0.2
  });
  
  const leftShoe = new THREE.Mesh(shoeGeo, shoeMat);
  leftShoe.position.set(-0.18, 0.06, 0.10);
  group.add(leftShoe);
  
  const rightShoe = new THREE.Mesh(shoeGeo, shoeMat);
  rightShoe.position.set(0.18, 0.06, 0.10);
  group.add(rightShoe);
  
  // Cleat spikes
  const spikeGeo = new THREE.ConeGeometry(0.02, 0.08, 8);
  const spikeMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
  for (let i = 0; i < 4; i++) {
    const spike1 = new THREE.Mesh(spikeGeo, spikeMat);
    spike1.position.set(-0.18 + (i - 1.5) * 0.06, 0.01, 0.10 + 0.08);
    group.add(spike1);
    const spike2 = new THREE.Mesh(spikeGeo, spikeMat);
    spike2.position.set(0.18 + (i - 1.5) * 0.06, 0.01, 0.10 + 0.08);
    group.add(spike2);
  }
  
  // Enable shadows
  group.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      child.castShadow = true;
      child.receiveShadow = true;
    }
  });
  
  group.position.set(position.x, position.y, position.z);
  group.rotation.y = rotationY;
  
  return group;
}

function createPlayers() {
  // Pitcher - hyperrealistic figure
  pitcher = createHumanFigure('#0d4f8c', { x: 0, y: 0, z: -18.4 }, 0, true);
  scene.add(pitcher);

  // Batter - hyperrealistic figure
  batter = createHumanFigure('#c41e3a', { x: -1, y: 0, z: 2 }, Math.PI, false);
  scene.add(batter);

  // Hyperrealistic baseball with detailed stitching
  const ballGeometry = new THREE.SphereGeometry(0.15, 32, 32);
  const ballTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // White leather base
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 256, 256);
    
    // Add leather texture
    for (let i = 0; i < 500; i++) {
      const x = Math.random() * 256;
      const y = Math.random() * 256;
      const gray = 240 + Math.random() * 15;
      ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
      ctx.fillRect(x, y, 2, 2);
    }
    
    // Red stitching pattern (figure-8)
    ctx.strokeStyle = '#cc0000';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    
    // Top stitching
    ctx.beginPath();
    ctx.arc(128, 64, 60, Math.PI, 0, false);
    ctx.stroke();
    
    // Bottom stitching
    ctx.beginPath();
    ctx.arc(128, 192, 60, 0, Math.PI, false);
    ctx.stroke();
    
    // Center lines
    ctx.beginPath();
    ctx.moveTo(128, 4);
    ctx.lineTo(128, 128);
    ctx.moveTo(128, 128);
    ctx.lineTo(128, 252);
    ctx.stroke();
    
    // Stitching detail
    ctx.strokeStyle = '#990000';
    ctx.lineWidth = 1;
    for (let y = 30; y < 226; y += 8) {
      const x1 = 128 - Math.sqrt(3600 - Math.pow(y - 128, 2));
      const x2 = 128 + Math.sqrt(3600 - Math.pow(y - 128, 2));
      if (x1 > 0 && x2 < 256) {
        ctx.beginPath();
        ctx.moveTo(x1, y);
        ctx.lineTo(x1 + 2, y);
        ctx.moveTo(x2 - 2, y);
        ctx.lineTo(x2, y);
        ctx.stroke();
      }
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
  })();
  
  const ballMat = new THREE.MeshStandardMaterial({ 
    map: ballTexture,
    color: 0xffffff,
    roughness: 0.5,
    metalness: 0.1,
    normalMap: ballTexture, // Simple normal for texture
    normalScale: new THREE.Vector2(0.5, 0.5)
  });
  ball = new THREE.Mesh(ballGeometry, ballMat);
  ball.position.set(0, 1.5, -18.4);
  ball.visible = false;
  ball.castShadow = true;
  scene.add(ball);
  
  // Realistic bat with wood grain
  if (bat) {
    scene.remove(bat);
  }
  const batGroup = new THREE.Group();
  
  const batHandleGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.65, 16);
  const batHandleMat = new THREE.MeshStandardMaterial({ 
    color: 0x8b4513,
    roughness: 0.8,
    metalness: 0.0
  });
  const batHandle = new THREE.Mesh(batHandleGeo, batHandleMat);
  batHandle.position.y = 1.2;
  batHandle.rotation.z = -Math.PI / 6;
  batGroup.add(batHandle);
  
  const batBarrelGeo = new THREE.CylinderGeometry(0.07, 0.03, 0.55, 16);
  const batWoodTexture = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, 128, 256);
    // Wood grain
    for (let i = 0; i < 50; i++) {
      const y = i * 5;
      ctx.strokeStyle = `rgba(139, 69, 19, ${0.3 + Math.random() * 0.4})`;
      ctx.lineWidth = 1 + Math.random();
      ctx.beginPath();
      ctx.moveTo(0, y + Math.sin(i) * 10);
      ctx.bezierCurveTo(
        30, y + Math.sin(i + 1) * 15,
        60, y + Math.sin(i + 2) * 10,
        128, y + Math.sin(i + 3) * 15
      );
      ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
  })();
  batWoodTexture.wrapS = THREE.RepeatWrapping;
  batWoodTexture.wrapT = THREE.RepeatWrapping;
  
  const batBarrelMat = new THREE.MeshStandardMaterial({ 
    map: batWoodTexture,
    color: 0x654321,
    roughness: 0.7,
    metalness: 0.0
  });
  const batBarrel = new THREE.Mesh(batBarrelGeo, batBarrelMat);
  batBarrel.position.y = 1.6;
  batBarrel.rotation.z = -Math.PI / 6;
  batGroup.add(batBarrel);
  
  batGroup.position.set(-1.2, 0, 2.2);
  batGroup.rotation.y = Math.PI;
  batGroup.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      child.castShadow = true;
    }
  });
  bat = batGroup;
  scene.add(bat);
}

function createFieldingPositions() {
  if (!fielders) fielders = {};
  
  try {
    // Catcher (behind home plate)
    fielders.catcher = createHumanFigure('#c41e3a', { x: 0, y: 0, z: -1.5 }, Math.PI, false);
    // Crouch position
    fielders.catcher.scale.y = 0.85;
    fielders.catcher.position.y = -0.15;
    scene.add(fielders.catcher);
    
    // First Baseman
    fielders.firstBase = createHumanFigure('#c41e3a', { x: 27.4, y: 0, z: 27.4 }, -Math.PI/4, false);
    scene.add(fielders.firstBase);
    
    // Second Baseman
    fielders.secondBase = createHumanFigure('#c41e3a', { x: 10, y: 0, z: 30 }, Math.PI/2, false);
    scene.add(fielders.secondBase);
    
    // Third Baseman
    fielders.thirdBase = createHumanFigure('#c41e3a', { x: -27.4, y: 0, z: 27.4 }, Math.PI/4, false);
    scene.add(fielders.thirdBase);
    
    // Shortstop
    fielders.shortstop = createHumanFigure('#c41e3a', { x: -10, y: 0, z: 30 }, Math.PI/2, false);
    scene.add(fielders.shortstop);
    
    // Left Fielder
    fielders.leftField = createHumanFigure('#c41e3a', { x: -50, y: 0, z: -40 }, 0, false);
    scene.add(fielders.leftField);
    
    // Center Fielder
    fielders.centerField = createHumanFigure('#c41e3a', { x: 0, y: 0, z: -60 }, 0, false);
    scene.add(fielders.centerField);
    
    // Right Fielder
    fielders.rightField = createHumanFigure('#c41e3a', { x: 50, y: 0, z: -40 }, 0, false);
    scene.add(fielders.rightField);
  } catch(e) {
    console.error('Error creating fielders:', e);
  }
}

function createDugouts() {
  if (!dugoutPlayers) dugoutPlayers = [];
  
  try {
    // Home team dugout (right side)
    const homeDugoutPlayers = [];
    for (let i = 0; i < 6; i++) {
      const player = createHumanFigure('#c41e3a', { 
        x: 35 + (i % 3) * 4, 
        y: 0, 
        z: 12 + Math.floor(i / 3) * 3 
      }, Math.PI/2, false);
      // Sitting/leaning position
      player.rotation.x = -0.3;
      player.scale.y = 0.9;
      scene.add(player);
      homeDugoutPlayers.push(player);
    }
    dugoutPlayers.push(...homeDugoutPlayers);
    
    // Away team dugout (left side)
    const awayDugoutPlayers = [];
    for (let i = 0; i < 6; i++) {
      const player = createHumanFigure('#0d4f8c', { 
        x: -35 - (i % 3) * 4, 
        y: 0, 
        z: 12 + Math.floor(i / 3) * 3 
      }, -Math.PI/2, true);
      player.rotation.x = -0.3;
      player.scale.y = 0.9;
      scene.add(player);
      awayDugoutPlayers.push(player);
    }
    dugoutPlayers.push(...awayDugoutPlayers);
  } catch(e) {
    console.error('Error creating dugouts:', e);
  }
}

function createRunnerAtBase(baseNumber) {
  if (runners[baseNumber]) {
    scene.remove(runners[baseNumber]);
  }
  
  const basePositions = [
    { x: 27.4, z: 27.4 }, // First base
    { x: 0, z: 38.8 },    // Second base
    { x: -27.4, z: 27.4 } // Third base
  ];
  
  const pos = basePositions[baseNumber - 1];
  const teamColor = gameState.topInning ? '#0d4f8c' : '#c41e3a';
  runners[baseNumber] = createHumanFigure(teamColor, { x: pos.x, y: 0, z: pos.z }, Math.PI/4, false);
  scene.add(runners[baseNumber]);
}

function removeRunner(baseNumber) {
  if (runners[baseNumber]) {
    scene.remove(runners[baseNumber]);
    delete runners[baseNumber];
  }
}

function updateBaseRunners() {
  if (!runners) runners = {};
  
  try {
    // Remove all runners
    Object.keys(runners).forEach(base => {
      removeRunner(parseInt(base));
    });
    
    // Add runners on occupied bases
    if (gameState.bases[0]) createRunnerAtBase(1);
    if (gameState.bases[1]) createRunnerAtBase(2);
    if (gameState.bases[2]) createRunnerAtBase(3);
  } catch(e) {
    console.error('Error updating runners:', e);
  }
}

function animatePitcher() {
  if (!pitcher) return;
  
  try {
    // Find right arm and left arm by searching
    let rightUpperArm = null, leftUpperArm = null;
    pitcher.children.forEach(child => {
      if (child.position && child.position.x > 0 && child.position.x < 1) {
        rightUpperArm = child;
      } else if (child.position && child.position.x < 0 && child.position.x > -1) {
        leftUpperArm = child;
      }
    });
    
    if (animationState.pitcher === 'windup') {
      if (rightUpperArm) rightUpperArm.rotation.z = -1.5;
      if (leftUpperArm) leftUpperArm.rotation.z = 0.8;
      pitcher.position.z -= 0.2;
    } else if (animationState.pitcher === 'delivery') {
      if (rightUpperArm) {
        rightUpperArm.rotation.z = 1.2;
        rightUpperArm.rotation.x = -0.5;
      }
      pitcher.position.z -= 0.1;
    } else if (animationState.pitcher === 'follow') {
      if (rightUpperArm) rightUpperArm.rotation.z = 1.5;
      pitcher.rotation.y = 0.3;
    } else {
      // Ready position
      if (rightUpperArm) rightUpperArm.rotation.z = -0.4;
      if (leftUpperArm) leftUpperArm.rotation.z = 0.3;
      const time = Date.now() * 0.003;
      pitcher.position.y = Math.sin(time) * 0.02;
    }
  } catch(e) {
    // Fallback - just animate position
    const time = Date.now() * 0.003;
    pitcher.position.y = Math.sin(time) * 0.02;
  }
}

function animateBatter() {
  if (!batter) return;
  
  try {
    let rightUpperArm = null;
    batter.children.forEach(child => {
      if (child.position && child.position.x > 0 && child.position.x < 1) {
        rightUpperArm = child;
      }
    });
    
    if (animationState.batter === 'load') {
      if (rightUpperArm) rightUpperArm.rotation.z = -1.2;
      batter.position.y -= 0.1;
      batter.rotation.z = -0.1;
    } else if (animationState.batter === 'swing') {
      if (rightUpperArm) {
        rightUpperArm.rotation.z = 2.5;
        rightUpperArm.rotation.x = 0.8;
      }
      batter.rotation.z = 0.5;
      batter.position.y -= 0.15;
    } else if (animationState.batter === 'follow') {
      if (rightUpperArm) rightUpperArm.rotation.z = 3.0;
      batter.rotation.z = 0.8;
    } else {
      // Ready stance
      const time = Date.now() * 0.005;
      batter.position.y = Math.sin(time) * 0.03;
      batter.rotation.z = Math.sin(time) * 0.05;
      if (rightUpperArm) rightUpperArm.rotation.z = -0.8;
    }
  } catch(e) {
    // Fallback
    const time = Date.now() * 0.005;
    batter.position.y = Math.sin(time) * 0.03;
    batter.rotation.z = Math.sin(time) * 0.05;
  }
}

function animateFielders() {
  // Animate fielders in ready position
  if (!fielders) return;
  
  Object.keys(fielders).forEach(key => {
    const fielder = fielders[key];
    if (!fielder) return;
    
    try {
      const time = Date.now() * 0.002;
      fielder.position.y = Math.sin(time + key.length) * 0.015;
    } catch(e) {
      // Ignore errors
    }
  });
}

function animateRunners() {
  // Animate base runners
  if (!runners) return;
  
  Object.keys(runners).forEach(base => {
    const runner = runners[base];
    if (!runner) return;
    
    try {
      const time = Date.now() * 0.01;
      runner.position.y = Math.sin(time + parseInt(base)) * 0.02;
    } catch(e) {
      // Ignore errors
    }
  });
}

function animate() {
  requestAnimationFrame(animate);
  
  // Animate pitcher
  animatePitcher();
  
  // Animate batter
  animateBatter();
  
  // Animate fielders
  animateFielders();
  
  // Animate runners
  animateRunners();
  
  // Animate bat swing with realistic motion
  if (bat && gameState.waitingForSwing) {
    const time = Date.now() * 0.01;
    bat.rotation.x = Math.sin(time) * 0.08 - 0.3;
    bat.position.y = Math.sin(time * 1.5) * 0.05;
  }
  
  // Update swing power bar
  if (swingCharging && gameState.waitingForSwing) {
    swingPower = Math.min(100, swingPower + 2);
    const powerBar = document.getElementById('swingPower');
    if (powerBar) powerBar.style.width = swingPower + '%';
  }
  
  // Camera subtle movement for realism (more stable, closer)
  if (camera) {
    const time = Date.now() * 0.001;
    camera.position.x = Math.sin(time * 0.3) * 0.2;
    camera.position.y = 18 + Math.sin(time * 0.2) * 0.15;
  }
  
  renderer.render(scene, camera);
}

function updateScoreboard() {
  document.getElementById('inningDisplay').textContent = 
    (gameState.topInning ? 'TOP' : 'BOT') + ' ' + gameState.inning;
  document.getElementById('outsDisplay').textContent = gameState.outs + ' OUTS';
  document.getElementById('visitorScore').textContent = gameState.visitorScore;
  document.getElementById('homeScore').textContent = gameState.homeScore;
  document.getElementById('visitorHits').textContent = gameState.visitorHits + ' H';
  document.getElementById('homeHits').textContent = gameState.homeHits + ' H';
  document.getElementById('countDisplay').textContent = gameState.balls + '-' + gameState.strikes;
  
  // Update bases display
  document.getElementById('base1').style.background = gameState.bases[0] ? '#ffd700' : 'rgba(255,255,255,0.2)';
  document.getElementById('base2').style.background = gameState.bases[1] ? '#ffd700' : 'rgba(255,255,255,0.2)';
  document.getElementById('base3').style.background = gameState.bases[2] ? '#ffd700' : 'rgba(255,255,255,0.2)';
  
  // Update base runners
  updateBaseRunners();
}

function addGameLog(message) {
  const log = document.getElementById('gameLog');
  const entry = document.createElement('div');
  entry.style.marginBottom = '8px';
  entry.style.opacity = '0.9';
  entry.textContent = message;
  log.insertBefore(entry, log.firstChild);
  if (log.children.length > 10) {
    log.removeChild(log.lastChild);
  }
}

function pitchBall() {
  if (gameState.ballInFlight) return;
  
  gameState.ballInFlight = true;
  gameState.waitingForSwing = false;
  ball.visible = true;
  ball.position.set(0, 1.5, -18.4);
  ball.rotation.set(0, 0, 0);
  
  // Pitch parameters
  const targetZ = Math.random() * 25 + 8;
  const targetX = (Math.random() - 0.5) * 3;
  const height = Math.random() * 2.5 + 0.8;
  const speed = 0.025;
  
  currentPitch = {
    targetX, targetZ, height,
    startTime: Date.now(),
    swingWindow: { start: 450, end: 650 } // milliseconds
  };
  
  // Realistic pitcher animation sequence
  animationState.pitcher = 'windup';
  setTimeout(() => {
    animationState.pitcher = 'delivery';
    setTimeout(() => {
      animationState.pitcher = 'follow';
      setTimeout(() => {
        animationState.pitcher = 'ready';
      }, 400);
    }, 100);
  }, 300);
  
  let progress = 0;
  const pitchStartTime = Date.now();
  
  const pitchInterval = setInterval(() => {
    progress += speed;
    const elapsed = Date.now() - pitchStartTime;
    
    if (progress >= 1) {
      progress = 1;
      clearInterval(pitchInterval);
      
      // If no swing in bat/full mode, auto-miss
      if ((gameMode === 'bat' || gameMode === 'full') && !swingTiming) {
        handlePitchResult('strike');
      } else if (gameMode === 'computer' || gameMode === 'pitch') {
        // Auto-determine outcome for computer/pitch modes
        determinePitchOutcome(targetX, targetZ, height);
      }
      
      return;
    }
    
    // Realistic physics-based ball flight with curve
    const t = progress;
    const lerp = (a, b, t) => a + (b - a) * t;
    const easeOut = (t) => 1 - Math.pow(1 - t, 3);
    const eased = easeOut(t);
    
    // Realistic trajectory with gravity and curve
    const gravity = 9.8 * 0.02; // Gravity effect
    const curveAmount = (Math.random() - 0.5) * 0.5; // Pitch curve
    
    const x = lerp(0, targetX, eased) + Math.sin(t * Math.PI) * curveAmount;
    const baseY = 1.5 + (height * Math.sin(t * Math.PI)) - (gravity * t * t * 60);
    const y = Math.max(0.3, baseY);
    const z = lerp(-18.4, targetZ, eased);
    
    ball.position.set(x, y, z);
    
    // Rotate ball for realism
    ball.rotation.x += 0.5;
    ball.rotation.y += 0.3;
    
    // Check for swing timing (in bat/full modes)
    if ((gameMode === 'bat' || gameMode === 'full') && !gameState.waitingForSwing && elapsed > 300) {
      gameState.waitingForSwing = true;
      document.getElementById('battingUI').style.display = 'block';
      swingPower = 0;
      swingCharging = true;
    }
    
    // Check if swing happened
    if (swingTiming && elapsed >= swingTiming && elapsed < swingTiming + 200) {
      clearInterval(pitchInterval);
      handleSwing(swingPower, targetX, targetZ);
      swingTiming = null;
      return;
    }
  }, 16);
}

function handleSwing(power, pitchX, pitchZ) {
  gameState.waitingForSwing = false;
  swingCharging = false;
  document.getElementById('battingUI').style.display = 'none';
  document.getElementById('swingPower').style.width = '0%';
  
  // Animate bat swing
  if (bat) {
    const originalRot = bat.rotation.x;
    bat.rotation.x = -Math.PI / 2;
    setTimeout(() => {
      if (bat) bat.rotation.x = originalRot;
    }, 300);
  }
  
  // Calculate hit based on power and timing
  const distanceFromStrikeZone = Math.sqrt(pitchX * pitchX + (pitchZ - 10) * (pitchZ - 10));
  const powerMultiplier = power / 100;
  
  let result;
  if (distanceFromStrikeZone < 0.8 && powerMultiplier > 0.3) {
    // Good contact
    if (powerMultiplier > 0.8) {
      result = 'homerun';
    } else if (powerMultiplier > 0.6) {
      result = Math.random() > 0.5 ? 'triple' : 'double';
    } else {
      result = 'single';
    }
  } else if (distanceFromStrikeZone < 1.2) {
    result = 'foul';
  } else {
    result = 'strike';
  }
  
  handlePitchResult(result, powerMultiplier);
  swingTiming = null;
}

function determinePitchOutcome(pitchX, pitchZ, height) {
  const outcome = Math.random();
  let result;
  
  if (outcome < 0.25) {
    result = 'strike';
  } else if (outcome < 0.55) {
    const hitType = Math.random();
    if (hitType < 0.5) result = 'single';
    else if (hitType < 0.8) result = 'double';
    else if (hitType < 0.95) result = 'triple';
    else result = 'homerun';
  } else {
    result = 'ball';
  }
  
  handlePitchResult(result);
}

function handlePitchResult(result, power = 0.5) {
  gameState.ballInFlight = false;
  ball.visible = false;
  gameState.waitingForSwing = false;
  swingTiming = null;
  swingPower = 0;
  swingCharging = false;
  
  if (result === 'strike' || result === 'foul') {
    gameState.strikes++;
    if (gameState.strikes >= 3) {
      addGameLog('Strikeout!');
      gameState.outs++;
      gameState.strikes = 0;
      gameState.balls = 0;
      if (gameState.outs >= 3) {
        endHalfInning();
      } else {
        nextBatter();
        setTimeout(() => continueAfterResult(), 1500);
      }
    } else {
      addGameLog(result === 'foul' ? 'Foul ball!' : 'Strike!');
      updateScoreboard();
      setTimeout(() => continueAfterResult(), 1500);
    }
  } else if (result === 'ball') {
    gameState.balls++;
    if (gameState.balls >= 4) {
      addGameLog('Walk!');
      advanceBases(true);
      gameState.balls = 0;
      gameState.strikes = 0;
      updateScoreboard();
      setTimeout(() => continueAfterResult(), 1500);
    } else {
      addGameLog('Ball!');
      updateScoreboard();
      setTimeout(() => continueAfterResult(), 1500);
    }
  } else {
    // Hit
    const isHomeTeam = !gameState.topInning;
    if (isHomeTeam) gameState.homeHits++;
    else gameState.visitorHits++;
    
    gameState.strikes = 0;
    gameState.balls = 0;
    
    if (result === 'homerun') {
      addGameLog('HOME RUN!');
      let runs = 1;
      if (gameState.bases[0]) { runs++; gameState.bases[0] = false; }
      if (gameState.bases[1]) { runs++; gameState.bases[1] = false; }
      if (gameState.bases[2]) { runs++; gameState.bases[2] = false; }
      if (isHomeTeam) gameState.homeScore += runs;
      else gameState.visitorScore += runs;
      addGameLog(`${runs} ${runs === 1 ? 'run' : 'runs'} score!`);
    } else if (result === 'triple') {
      addGameLog('Triple!');
      advanceBases(false, 3);
      gameState.bases[2] = true;
    } else if (result === 'double') {
      addGameLog('Double!');
      advanceBases(false, 2);
      gameState.bases[1] = true;
    } else {
      addGameLog('Single!');
      advanceBases(false, 1);
      gameState.bases[0] = true;
    }
    updateScoreboard();
    setTimeout(() => continueAfterResult(), 2000);
  }
}

function continueAfterResult() {
  if (gameMode === 'computer') {
    // Computer mode continues automatically
    return;
  } else if (gameMode === 'bat' && !gameState.ballInFlight) {
    // Auto-pitch in bat mode
    setTimeout(() => pitchBall(), 500);
  }
}

function advanceBases(isWalk, basesAdvanced = 1) {
  const isHomeTeam = !gameState.topInning;
  let runs = 0;
  
  for (let i = 2; i >= 0; i--) {
    if (gameState.bases[i]) {
      const newBase = i + basesAdvanced;
      gameState.bases[i] = false;
      if (newBase >= 3) {
        runs++;
      } else {
        gameState.bases[newBase] = true;
      }
    }
  }
  
  if (isWalk && gameState.bases[0] && gameState.bases[1] && gameState.bases[2]) {
    runs++;
    gameState.bases[2] = false;
  }
  
  if (runs > 0) {
    if (isHomeTeam) gameState.homeScore += runs;
    else gameState.visitorScore += runs;
    addGameLog(`${runs} ${runs === 1 ? 'run' : 'runs'} score!`);
  }
}

function nextBatter() {
  gameState.strikes = 0;
  gameState.balls = 0;
  updateScoreboard();
}

function endHalfInning() {
  gameState.outs = 0;
  gameState.bases = [false, false, false];
  gameState.strikes = 0;
  gameState.balls = 0;
  
  if (gameState.topInning) {
    gameState.topInning = false;
    addGameLog(`End of top ${gameState.inning}. Red Sox coming to bat!`);
  } else {
    gameState.topInning = true;
    gameState.inning++;
    addGameLog(`End of inning ${gameState.inning - 1}.`);
    if (gameState.inning > 9) {
      addGameLog('GAME OVER!');
      stopComputerPlay();
      document.getElementById('pitchBtn').disabled = true;
      document.getElementById('swingBtn').disabled = true;
      document.getElementById('nextPlayBtn').disabled = true;
    }
  }
  updateScoreboard();
}

function endHalfInning() {
  gameState.outs = 0;
  gameState.bases = [false, false, false];
  
  if (gameState.topInning) {
    gameState.topInning = false;
    addGameLog(`End of top ${gameState.inning}. Red Sox coming to bat!`);
  } else {
    gameState.topInning = true;
    gameState.inning++;
    addGameLog(`End of inning ${gameState.inning - 1}.`);
    if (gameState.inning > 9) {
      addGameLog('GAME OVER!');
      document.getElementById('pitchBtn').disabled = true;
    }
  }
  updateScoreboard();
}

function resetGame() {
  stopComputerPlay();
  gameState = {
    inning: 1,
    topInning: true,
    outs: 0,
    visitorScore: 0,
    homeScore: 0,
    visitorHits: 0,
    homeHits: 0,
    bases: [false, false, false],
    ballPosition: null,
    ballInFlight: false,
    strikes: 0,
    balls: 0,
    waitingForSwing: false
  };
  ball.visible = false;
  swingPower = 0;
  swingCharging = false;
  swingTiming = null;
  gameState.waitingForSwing = false;
  document.getElementById('battingUI').style.display = 'none';
  document.getElementById('swingPower').style.width = '0%';
  updateScoreboard();
  document.getElementById('gameLog').innerHTML = '';
  enableControls();
  addGameLog('Game reset. Play ball!');
  
  if (gameMode === 'computer') {
    startComputerPlay();
  }
}

function setGameMode(mode) {
  stopComputerPlay();
  gameMode = mode;
  
  // Update mode buttons
  document.querySelectorAll('[data-mode]').forEach(btn => {
    if (btn.dataset.mode === mode) {
      btn.style.background = 'linear-gradient(135deg, #c41e3a, #0d4f8c)';
    } else {
      btn.style.background = 'rgba(255,255,255,0.2)';
    }
  });
  
  // Update controls visibility
  enableControls();
  
  if (mode === 'computer') {
    addGameLog('Computer Play mode - Game will simulate automatically');
    startComputerPlay();
  } else if (mode === 'pitch') {
    addGameLog('Pitch Only mode - You control the pitcher');
  } else if (mode === 'bat') {
    addGameLog('Bat Only mode - You control the batter');
  } else {
    addGameLog('Full Play mode - You control both pitcher and batter');
  }
}

function enableControls() {
  const pitchBtn = document.getElementById('pitchBtn');
  const swingBtn = document.getElementById('swingBtn');
  const nextBtn = document.getElementById('nextPlayBtn');
  
  if (gameMode === 'computer') {
    pitchBtn.style.display = 'none';
    swingBtn.style.display = 'none';
    nextBtn.style.display = 'inline-block';
  } else if (gameMode === 'pitch') {
    pitchBtn.style.display = 'inline-block';
    swingBtn.style.display = 'none';
    nextBtn.style.display = 'none';
  } else if (gameMode === 'bat') {
    pitchBtn.style.display = 'none';
    swingBtn.style.display = 'inline-block';
    nextBtn.style.display = 'none';
    // Auto-pitch in bat mode
    if (!gameState.ballInFlight) {
      setTimeout(() => pitchBall(), 500);
    }
  } else {
    pitchBtn.style.display = 'inline-block';
    swingBtn.style.display = 'inline-block';
    nextBtn.style.display = 'none';
  }
  
  pitchBtn.disabled = false;
  swingBtn.disabled = false;
  nextBtn.disabled = false;
}

function startComputerPlay() {
  if (gameMode !== 'computer' || gameState.inning > 9) return;
  
  if (computerPlayInterval) clearInterval(computerPlayInterval);
  
  computerPlayInterval = setInterval(() => {
    if (gameState.ballInFlight || gameState.inning > 9) return;
    pitchBall();
  }, 2500);
}

function stopComputerPlay() {
  if (computerPlayInterval) {
    clearInterval(computerPlayInterval);
    computerPlayInterval = null;
  }
}

function swingBat() {
  if (!gameState.waitingForSwing || !swingCharging) return;
  
  swingTiming = Date.now();
  swingCharging = false;
  
  // Realistic batter swing animation
  animationState.batter = 'load';
  setTimeout(() => {
    animationState.batter = 'swing';
    setTimeout(() => {
      animationState.batter = 'follow';
      setTimeout(() => {
        animationState.batter = 'ready';
      }, 500);
    }, 150);
  }, 50);
  
  document.getElementById('swingIndicator').textContent = '‚öæ';
  setTimeout(() => {
    if (document.getElementById('swingIndicator')) {
      document.getElementById('swingIndicator').textContent = 'üëÅÔ∏è';
    }
  }, 500);
}

// Baseball game button handlers
document.addEventListener('DOMContentLoaded', () => {
  // Mode selection
  document.querySelectorAll('[data-mode]').forEach(btn => {
    btn.onclick = () => setGameMode(btn.dataset.mode);
  });
  
  // Game controls
  const pitchBtn = document.getElementById('pitchBtn');
  const swingBtn = document.getElementById('swingBtn');
  const resetBtn = document.getElementById('resetGameBtn');
  const nextBtn = document.getElementById('nextPlayBtn');
  
  if (pitchBtn) pitchBtn.onclick = pitchBall;
  if (swingBtn) swingBtn.onclick = swingBat;
  if (resetBtn) resetBtn.onclick = resetGame;
  if (nextBtn) nextBtn.onclick = () => {
    if (!gameState.ballInFlight) {
      if (gameMode === 'computer') pitchBall();
      else addGameLog('Use Pitch or Swing buttons in this mode');
    }
  };
  
  // Keyboard controls
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && gameState.waitingForSwing) {
      e.preventDefault();
      swingBat();
    } else if (e.code === 'KeyP' && (gameMode === 'pitch' || gameMode === 'full')) {
      if (!gameState.ballInFlight) pitchBall();
    }
  });
  
  // Initialize default mode
  setGameMode('computer');
});
</script>
</body>
</html>